<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libpalliate: toml11</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- Dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libpalliate<span id="projectnumber">&#160;v0.0.1</span>
   </div>
   <div id="projectbrief">Palliate core library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md____w_libpalliate_libpalliate_libpalliate_toml11_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">toml11 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a href="https://github.com/ToruNiina/toml11/actions"><img src="https://github.com/ToruNiina/toml11/workflows/build/badge.svg" alt="Build Status on GitHub Actions" style="pointer-events: none;" class="inline"/></a> <a href="https://travis-ci.org/ToruNiina/toml11"><img src="https://travis-ci.org/ToruNiina/toml11.svg?branch=master" alt="Build Status on TravisCI" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/ToruNiina/toml11/branch/master"><img src="https://ci.appveyor.com/api/projects/status/m2n08a926asvg5mg/branch/master?svg=true" alt="Build status on Appveyor" class="inline"/></a> <a href="https://circleci.com/gh/ToruNiina/toml11/tree/master"><img src="https://circleci.com/gh/ToruNiina/toml11/tree/master.svg?style=svg" alt="Build status on CircleCI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/ToruNiina/toml11/releases"><img src="https://img.shields.io/github/release/ToruNiina/toml11.svg?style=flat" alt="Version" style="pointer-events: none;" class="inline"/></a> [<img src="https://img.shields.io/github/license/ToruNiina/toml11.svg?style=flat" alt="License" style="pointer-events: none;" class="inline"/>](LICENSE) <a href="https://doi.org/10.5281/zenodo.1209136"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1209136.svg" alt="DOI" style="pointer-events: none;" class="inline"/></a></p>
<p >toml11 is a C++11 (or later) header-only toml parser/encoder depending only on C++ standard library.</p>
<ul>
<li>It is compatible to the latest version of <a href="https://toml.io/en/v1.0.0">TOML v1.0.0</a>.</li>
<li>It is one of the most TOML standard compliant libraries, tested with <a href="https://github.com/BurntSushi/toml-test">the language agnostic test suite for TOML parsers by BurntSushi</a>.</li>
<li>It shows highly informative error messages. You can see the error messages about invalid files at <a href="https://circleci.com/gh/ToruNiina/toml11">CircleCI</a>.</li>
<li>It has configurable container. You can use any random-access containers and key-value maps as backend containers.</li>
<li>It optionally preserves comments without any overhead.</li>
<li>It has configurable serializer that supports comments, inline tables, literal strings and multiline strings.</li>
<li>It supports user-defined type conversion from/into toml values.</li>
<li>It correctly handles UTF-8 sequences, with or without BOM, both on posix and Windows.</li>
</ul>
<h1><a class="anchor" id="autotoc_md0"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="toml_8hpp.html">toml.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="check_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ```toml</span></div>
<div class="line">    <span class="comment">// title = &quot;an example toml file&quot;</span></div>
<div class="line">    <span class="comment">// nums  = [3, 1, 4, 1, 5]</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="ttc" id="acheck_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="check_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> check.cpp:5</div></div>
<div class="ttc" id="atoml_8hpp_html"><div class="ttname"><a href="toml_8hpp.html">toml.hpp</a></div></div>
</div><!-- fragment --><p> auto data = <a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>("example.toml");</p>
<p >// find a value with the specified type from a table std::string title = <a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find&lt;std::string&gt;</a>(data, "title");</p>
<p >// convert the whole array into any container automatically std::vector&lt;int&gt; nums = <a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find&lt;std::vector&lt;int&gt;&gt;</a>(data, "nums");</p>
<p >// access with STL-like manner if(!data.contains("foo")) { data["foo"] = "bar"; }</p>
<p >// pass a fallback std::string name = <a class="el" href="namespacetoml.html#a34fb7cea6c5ed3988dd2d3944bfd6b2a">toml::find_or&lt;std::string&gt;</a>(data, "name", "not found");</p>
<p >// width-dependent formatting std::cout &lt;&lt; std::setw(80) &lt;&lt; data &lt;&lt; std::endl;</p>
<p >return 0; } </p><div class="fragment"><div class="line">## Table of Contents</div>
<div class="line"> </div>
<div class="line">- [Integration](#integration)</div>
<div class="line">- [Decoding a toml file](#decoding-a-toml-file)</div>
<div class="line">  - [In the case of syntax error](#in-the-case-of-syntax-error)</div>
<div class="line">  - [Invalid UTF-8 Codepoints](#invalid-utf-8-codepoints)</div>
<div class="line">- [Finding a toml value](#finding-a-toml-value)</div>
<div class="line">  - [Finding a value in a table](#finding-a-value-in-a-table)</div>
<div class="line">  - [In case of error](#in-case-of-error)</div>
<div class="line">  - [Dotted keys](#dotted-keys)</div>
<div class="line">- [Casting a toml value](#casting-a-toml-value)</div>
<div class="line">- [Checking value type](#checking-value-type)</div>
<div class="line">- [More about conversion](#more-about-conversion)</div>
<div class="line">  - [Converting an array](#converting-an-array)</div>
<div class="line">  - [Converting a table](#converting-a-table)</div>
<div class="line">  - [Getting an array of tables](#getting-an-array-of-tables)</div>
<div class="line">  - [Cost of conversion](#cost-of-conversion)</div>
<div class="line">  - [Converting datetime and its variants](#converting-datetime-and-its-variants)</div>
<div class="line">- [Getting with a fallback](#getting-with-a-fallback)</div>
<div class="line">- [Expecting conversion](#expecting-conversion)</div>
<div class="line">- [Visiting a toml::value](#visiting-a-tomlvalue)</div>
<div class="line">- [Constructing a toml::value](#constructing-a-tomlvalue)</div>
<div class="line">- [Preserving Comments](#preserving-comments)</div>
<div class="line">- [Customizing containers](#customizing-containers)</div>
<div class="line">- [TOML literal](#toml-literal)</div>
<div class="line">- [Conversion between toml value and arbitrary types](#conversion-between-toml-value-and-arbitrary-types)</div>
<div class="line">- [Formatting user-defined error messages](#formatting-user-defined-error-messages)</div>
<div class="line">- [Obtaining location information](#obtaining-location-information)</div>
<div class="line">- [Exceptions](#exceptions)</div>
<div class="line">- [Colorize Error Messages](#colorize-error-messages)</div>
<div class="line">- [Serializing TOML data](#serializing-toml-data)</div>
<div class="line">- [Underlying types](#underlying-types)</div>
<div class="line">- [Unreleased TOML features](#unreleased-toml-features)</div>
<div class="line">- [Breaking Changes from v2](#breaking-changes-from-v2)</div>
<div class="line">- [Running Tests](#running-tests)</div>
<div class="line">- [Contributors](#contributors)</div>
<div class="line">- [Licensing Terms](#licensing-terms)</div>
<div class="line"> </div>
<div class="line">## Integration</div>
<div class="line"> </div>
<div class="line">Just include the file after adding it to the include path.</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">#include &lt;toml.hpp&gt; // that&#39;s all! now you can use it.</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    const auto data  = toml::parse(&quot;example.toml&quot;);</div>
<div class="line">    const auto title = toml::find&lt;std::string&gt;(data, &quot;title&quot;);</div>
<div class="line">    std::cout &lt;&lt; &quot;the title is &quot; &lt;&lt; title &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The convenient way is to add this repository as a git-submodule or to install it in your system by CMake.</p>
<p >Note for MSVC: We recommend to set <code>/Zc:__cplusplus</code> to detect C++ version correctly.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Decoding a toml file</h1>
<p >To parse a toml file, the only thing you have to do is to pass a filename to the <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string fname(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(fname);</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html"><div class="ttname"><a href="classtoml_1_1basic__value.html">toml::basic_value</a></div><div class="ttdef"><b>Definition:</b> value.hpp:172</div></div>
<div class="ttc" id="anamespacetoml_html_ad3d7c729037d3e6cb19515babf8539a3"><div class="ttname"><a href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></div><div class="ttdeci">basic_value&lt; Comment, Table, Array &gt; parse(std::istream &amp;is, std::string fname=&quot;unknown file&quot;)</div><div class="ttdef"><b>Definition:</b> parser.hpp:2320</div></div>
</div><!-- fragment --><p >As required by the TOML specification, the top-level value is always a table. You can find a value inside it, cast it into a table explicitly, and insert it as a value into other <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<p >If it encounters an error while opening a file, it will throw <code>std::runtime_error</code>.</p>
<p >You can also pass a <code>std::istream</code> to the <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> function. To show a filename in an error message, however, it is recommended to pass the filename with the stream.</p>
<div class="fragment"><div class="line">std::ifstream ifs(<span class="stringliteral">&quot;sample.toml&quot;</span>, std::ios_base::binary);</div>
<div class="line">assert(ifs.good());</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(ifs, <span class="comment">/*optional -&gt; */</span> <span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
</div><!-- fragment --><p ><b>Note</b>: When you are <b>on Windows, open a file in binary mode</b>. If a file is opened in text-mode, CRLF ("\r\n") will automatically be converted to LF ("\n") and this causes inconsistency between file size and the contents that would be read. This causes weird error.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
In the case of syntax error</h2>
<p >If there is a syntax error in a toml file, <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> will throw <code><a class="el" href="structtoml_1_1syntax__error.html">toml::syntax_error</a></code> that inherits <code>std::exception</code>.</p>
<p >toml11 has clean and informative error messages inspired by Rust and it looks like the following.</p>
<div class="fragment"><div class="line">terminate called after throwing an instance of &#39;toml::syntax_error&#39;</div>
<div class="line">  what():  [error] toml::parse_table: invalid line format # error description</div>
<div class="line"> --&gt; example.toml                                         # file name</div>
<div class="line"> 3 | a = 42 = true                                        # line num and content</div>
<div class="line">   |        ^------ expected newline, but got &#39;=&#39;.        # error reason</div>
</div><!-- fragment --><p >If you (mistakenly) duplicate tables and got an error, it is helpful to see where they are. toml11 shows both at the same time like the following.</p>
<div class="fragment"><div class="line">terminate called after throwing an instance of &#39;toml::syntax_error&#39;</div>
<div class="line">  what():  [error] toml::insert_value: table (&quot;table&quot;) already exists.</div>
<div class="line"> --&gt; duplicate-table.toml</div>
<div class="line"> 1 | [table]</div>
<div class="line">   | ~~~~~~~ table already exists here</div>
<div class="line"> ...</div>
<div class="line"> 3 | [table]</div>
<div class="line">   | ~~~~~~~ table defined twice</div>
</div><!-- fragment --><p >When toml11 encounters a malformed value, it tries to detect what type it is. Then it shows hints to fix the format. An error message while reading one of the malformed files in <a href="https://github.com/BurntSushi/toml-test">the language agnostic test suite</a>. is shown below.</p>
<div class="fragment"><div class="line">what(): [error] bad time: should be HH:MM:SS.subsec</div>
<div class="line"> --&gt; ./datetime-malformed-no-secs.toml</div>
<div class="line"> 1 | no-secs = 1987-07-05T17:45Z</div>
<div class="line">   |                     ^------- HH:MM:SS.subsec</div>
<div class="line">   |</div>
<div class="line">Hint: pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999</div>
<div class="line">Hint: fail: 1979-05-27T7:32:00, 1979-05-27 17:32</div>
</div><!-- fragment --><p >You can find other examples in a job named <code>output_result</code> on <a href="https://circleci.com/gh/ToruNiina/toml11">CircleCI</a>.</p>
<p >Since the error message generation is generally a difficult task, the current status is not ideal. If you encounter a weird error message, please let us know and contribute to improve the quality!</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Invalid UTF-8 codepoints</h2>
<p >It throws <code>syntax_error</code> if a value of an escape sequence representing unicode character is not a valid UTF-8 codepoint.</p>
<div class="fragment"><div class="line"> what():  [error] toml::read_utf8_codepoint: input codepoint is too large.</div>
<div class="line">--&gt; utf8.toml</div>
<div class="line">1 | exceeds_unicode = &quot;\U0011FFFF example&quot;</div>
<div class="line">  |                              ^--------- should be in [0x00..0x10FFFF]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Finding a toml value</h1>
<p >After parsing successfully, you can obtain the values from the result of <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> using <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> function.</p>
<div class="fragment"><div class="line"># sample.toml</div>
<div class="line">answer  = 42</div>
<div class="line">pi      = 3.14</div>
<div class="line">numbers = [1,2,3]</div>
<div class="line">time    = 1979-05-27T07:32:00Z</div>
</div><!-- fragment --><div class="fragment"><div class="line">const auto data      = toml::parse(&quot;sample.toml&quot;);</div>
<div class="line">const auto answer    = toml::find&lt;std::int64_t    &gt;(data, &quot;answer&quot;);</div>
<div class="line">const auto pi        = toml::find&lt;double          &gt;(data, &quot;pi&quot;);</div>
<div class="line">const auto numbers   = toml::find&lt;std::vector&lt;int&gt;&gt;(data, &quot;numbers&quot;);</div>
<div class="line">const auto timepoint = toml::find&lt;std::chrono::system_clock::time_point&gt;(data, &quot;time&quot;);</div>
</div><!-- fragment --><p >By default, <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> returns a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>&amp; answer = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>(data, <span class="stringliteral">&quot;answer&quot;</span>);</div>
<div class="ttc" id="anamespacetoml_html_a31abd17e078e497fb224d79260910b8d"><div class="ttname"><a href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></div><div class="ttdeci">decltype(::toml::get&lt; T &gt;(std::declval&lt; basic_value&lt; C, M, V &gt; const &amp; &gt;())) find(const basic_value&lt; C, M, V &gt; &amp;v, const key &amp;ky)</div><div class="ttdef"><b>Definition:</b> get.hpp:553</div></div>
</div><!-- fragment --><p >When you pass an exact TOML type that does not require type conversion, <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> returns a reference without copying the value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>  data   = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; answer = toml::find&lt;toml::integer&gt;(data, <span class="stringliteral">&quot;answer&quot;</span>);</div>
</div><!-- fragment --><p >If the specified type requires conversion, you can't take a reference to the value. See also underlying types.</p>
<p ><b>NOTE</b>: For some technical reason, automatic conversion between <code>integer</code> and <code>floating</code> is not supported. If you want to get a floating value even if a value has integer value, you need to convert it manually after obtaining a value, like the following.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> vx = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>(data, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> x = vx.is_floating() ? vx.as_floating(std::nothrow) :</div>
<div class="line">           <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(vx.as_integer()); <span class="comment">// it throws if vx is neither</span></div>
<div class="line">                                                 <span class="comment">// floating nor integer.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Finding a value in a table</h2>
<p >There are several way to get a value defined in a table. First, you can get a table as a normal value and find a value from the table.</p>
<div class="fragment"><div class="line">[fruit]</div>
<div class="line">name = &quot;apple&quot;</div>
<div class="line">[fruit.physical]</div>
<div class="line">color = &quot;red&quot;</div>
<div class="line">shape = &quot;round&quot;</div>
</div><!-- fragment --><div class="fragment"><div class="line">const auto  data  = toml::parse(&quot;fruit.toml&quot;);</div>
<div class="line">const auto&amp; fruit = toml::find(data, &quot;fruit&quot;);</div>
<div class="line">const auto  name  = toml::find&lt;std::string&gt;(fruit, &quot;name&quot;);</div>
<div class="line"> </div>
<div class="line">const auto&amp; physical = toml::find(fruit, &quot;physical&quot;);</div>
<div class="line">const auto  color    = toml::find&lt;std::string&gt;(physical, &quot;color&quot;);</div>
<div class="line">const auto  shape    = toml::find&lt;std::string&gt;(physical, &quot;shape&quot;);</div>
</div><!-- fragment --><p >Here, variable <code>fruit</code> is a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> and can be used as the first argument of <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code>.</p>
<p >Second, you can pass as many arguments as the number of subtables to <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data  = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;fruit.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> color = toml::find&lt;std::string&gt;(data, <span class="stringliteral">&quot;fruit&quot;</span>, <span class="stringliteral">&quot;physical&quot;</span>, <span class="stringliteral">&quot;color&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> shape = toml::find&lt;std::string&gt;(data, <span class="stringliteral">&quot;fruit&quot;</span>, <span class="stringliteral">&quot;physical&quot;</span>, <span class="stringliteral">&quot;shape&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Finding a value in an array</h2>
<p >You can find n-th value in an array by <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code>.</p>
<div class="fragment"><div class="line">values = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</div>
</div><!-- fragment --><div class="fragment"><div class="line">const auto data   = toml::parse(&quot;sample.toml&quot;);</div>
<div class="line">const auto values = toml::find(data, &quot;values&quot;);</div>
<div class="line">const auto bar    = toml::find&lt;std::string&gt;(values, 1);</div>
</div><!-- fragment --><p ><code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> can also search array recursively.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;fruit.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bar  = toml::find&lt;std::string&gt;(data, <span class="stringliteral">&quot;values&quot;</span>, 1);</div>
</div><!-- fragment --><p >Before calling <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code>, you can check if a value corresponding to a key exists. You can use both <code>bool <a class="el" href="classtoml_1_1basic__value.html#aea6f51ec9e8bcdef5dc6ca6641ab5606">toml::value::contains(const key&amp;) const</a></code> and <code>std::size_t <a class="el" href="classtoml_1_1basic__value.html#a6854d91dd03053b3838ee111897d282a">toml::value::count(const key&amp;) const</a></code>. Those behaves like the <code>std::map::contains</code> and <code>std::map::count</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;fruit.toml&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(data.<a class="code hl_function" href="classtoml_1_1basic__value.html#aea6f51ec9e8bcdef5dc6ca6641ab5606">contains</a>(<span class="stringliteral">&quot;fruit&quot;</span>) &amp;&amp; data.<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(<span class="stringliteral">&quot;fruit&quot;</span>).<a class="code hl_function" href="classtoml_1_1basic__value.html#a6854d91dd03053b3838ee111897d282a">count</a>(<span class="stringliteral">&quot;physical&quot;</span>) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a6854d91dd03053b3838ee111897d282a"><div class="ttname"><a href="classtoml_1_1basic__value.html#a6854d91dd03053b3838ee111897d282a">toml::basic_value::count</a></div><div class="ttdeci">std::size_t count(const key_type &amp;k) const</div><div class="ttdef"><b>Definition:</b> value.hpp:1681</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ad497266e16a1aa285d224dcf51fa622a"><div class="ttname"><a href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">toml::basic_value::at</a></div><div class="ttdeci">value_type &amp; at(const key &amp;k)</div><div class="ttdef"><b>Definition:</b> value.hpp:1533</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aea6f51ec9e8bcdef5dc6ca6641ab5606"><div class="ttname"><a href="classtoml_1_1basic__value.html#aea6f51ec9e8bcdef5dc6ca6641ab5606">toml::basic_value::contains</a></div><div class="ttdeci">bool contains(const key_type &amp;k) const</div><div class="ttdef"><b>Definition:</b> value.hpp:1691</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
In case of error</h2>
<p >If the value does not exist, <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> throws <code>std::out_of_range</code> with the location of the table.</p>
<div class="fragment"><div class="line">terminate called after throwing an instance of &#39;std::out_of_range&#39;</div>
<div class="line">  what():  [error] key &quot;answer&quot; not found</div>
<div class="line"> --&gt; example.toml</div>
<div class="line"> 6 | [tab]</div>
<div class="line">   | ~~~~~ in this table</div>
</div><!-- fragment --><hr  />
<p >If the specified type differs from the actual value contained, it throws <code><a class="el" href="structtoml_1_1type__error.html">toml::type_error</a></code> that inherits <code>std::exception</code>.</p>
<p >Similar to the case of syntax error, toml11 also displays clean error messages. The error message when you choose <code>int</code> to get <code>string</code> value would be like this.</p>
<div class="fragment"><div class="line">terminate called after throwing an instance of &#39;toml::type_error&#39;</div>
<div class="line">  what():  [error] toml::value bad_cast to integer</div>
<div class="line"> --&gt; example.toml</div>
<div class="line"> 3 | title = &quot;TOML Example&quot;</div>
<div class="line">   |         ~~~~~~~~~~~~~~ the actual type is string</div>
</div><!-- fragment --><p ><b>NOTE</b>: In order to show this kind of error message, all the toml values have a pointer to represent its range in a file. The entire contents of a file is shared by <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>s and remains on the heap memory. It is recommended to destruct all the <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> classes after configuring your application if you have a large TOML file compared to the memory resource.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Dotted keys</h2>
<p >TOML v0.5.0 has a new feature named "dotted keys". You can chain keys to represent the structure of the data.</p>
<div class="fragment"><div class="line">physical.color = &quot;orange&quot;</div>
<div class="line">physical.shape = &quot;round&quot;</div>
</div><!-- fragment --><p >This is equivalent to the following.</p>
<div class="fragment"><div class="line">[physical]</div>
<div class="line">color = &quot;orange&quot;</div>
<div class="line">shape = &quot;round&quot;</div>
</div><!-- fragment --><p >You can get both of the above tables with the same c++ code.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> physical = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>(data, <span class="stringliteral">&quot;physical&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> color    = toml::find&lt;std::string&gt;(physical, <span class="stringliteral">&quot;color&quot;</span>);</div>
</div><!-- fragment --><p >The following code does not work for the above toml file.</p>
<div class="fragment"><div class="line"><span class="comment">// XXX this does not work!</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> color = toml::find&lt;std::string&gt;(data, <span class="stringliteral">&quot;physical.color&quot;</span>);</div>
</div><!-- fragment --><p >The above code works with the following toml file.</p>
<div class="fragment"><div class="line">&quot;physical.color&quot; = &quot;orange&quot;</div>
<div class="line"># equivalent to {&quot;physical.color&quot;: &quot;orange&quot;},</div>
<div class="line"># NOT {&quot;physical&quot;: {&quot;color&quot;: &quot;orange&quot;}}.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Casting a toml value</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
&lt;tt&gt;toml::get&lt;/tt&gt;</h2>
<p ><code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> returns <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>. <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> is a union type that can contain one of the following types.</p>
<ul>
<li><code><a class="el" href="namespacetoml.html#a536c45fdc142655af40475187d5a6702">toml::boolean</a></code> (<code>bool</code>)</li>
<li><code><a class="el" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a></code> (<code>std::int64_t</code>)</li>
<li><code><a class="el" href="namespacetoml.html#a54f4b85eab8f0d6e6f0149c5ba338f6a">toml::floating</a></code> (<code>double</code>)</li>
<li><code><a class="el" href="structtoml_1_1string.html">toml::string</a></code> (a type convertible to std::string)</li>
<li><code><a class="el" href="structtoml_1_1local__date.html">toml::local_date</a></code></li>
<li><code><a class="el" href="structtoml_1_1local__time.html">toml::local_time</a></code></li>
<li><code><a class="el" href="structtoml_1_1local__datetime.html">toml::local_datetime</a></code></li>
<li><code><a class="el" href="structtoml_1_1offset__datetime.html">toml::offset_datetime</a></code></li>
<li><code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> (by default, <code>std::vector&lt;<a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>&gt;</code>)<ul>
<li>It depends. See customizing containers for detail.</li>
</ul>
</li>
<li><code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> (by default, <code>std::unordered_map&lt;<a class="el" href="namespacetoml.html#ab00c292fbb2e761ef69fdafd6b813348">toml::key</a>, <a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>&gt;</code>)<ul>
<li>It depends. See customizing containers for detail.</li>
</ul>
</li>
</ul>
<p >To get a value inside, you can use <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>&lt;T&gt;()</code>. The usage is the same as <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>&lt;T&gt;</code> (actually, <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> internally uses <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> after casting a value to <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code>).</p>
<div class="fragment"><div class="line">const toml::value  data    = toml::parse(&quot;sample.toml&quot;);</div>
<div class="line">const toml::value  answer_ = toml::get&lt;toml::table &gt;(data).at(&quot;answer&quot;);</div>
<div class="line">const std::int64_t answer  = toml::get&lt;std::int64_t&gt;(answer_);</div>
</div><!-- fragment --><p >When you pass an exact TOML type that does not require type conversion, <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> returns a reference through which you can modify the content (if the <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> is <code>const</code>, it returns <code>const</code> reference).</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>   data    = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>   answer_ = toml::get&lt;toml::table &gt;(data).<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(<span class="stringliteral">&quot;answer&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a>&amp; answer = toml::get&lt;toml::integer&gt;(answer_);</div>
<div class="line">answer = 6 * 9; <span class="comment">// write to data.answer. now `answer_` contains 54.</span></div>
<div class="ttc" id="anamespacetoml_html_ad9642acd2a70ea10c7c6c1b53a3caac9"><div class="ttname"><a href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a></div><div class="ttdeci">std::int64_t integer</div><div class="ttdef"><b>Definition:</b> types.hpp:30</div></div>
</div><!-- fragment --><p >If the specified type requires conversion, you can't take a reference to the value. See also underlying types.</p>
<p >It also throws a <code><a class="el" href="structtoml_1_1type__error.html">toml::type_error</a></code> if the type differs.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
&lt;tt&gt;as_xxx&lt;/tt&gt;</h2>
<p >You can also use a member function to cast a value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::int64_t answer = data.<a class="code hl_function" href="classtoml_1_1basic__value.html#a7b113a731815356acb870bfe37b15e1b">as_table</a>().at(<span class="stringliteral">&quot;answer&quot;</span>).as_integer();</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a7b113a731815356acb870bfe37b15e1b"><div class="ttname"><a href="classtoml_1_1basic__value.html#a7b113a731815356acb870bfe37b15e1b">toml::basic_value::as_table</a></div><div class="ttdeci">table_type const &amp; as_table(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1219</div></div>
</div><!-- fragment --><p >It also throws a <code><a class="el" href="structtoml_1_1type__error.html">toml::type_error</a></code> if the type differs. If you are sure that the value <code>v</code> contains a value of the specified type, you can suppress checking by passing <code>std::nothrow</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; answer = data.<a class="code hl_function" href="classtoml_1_1basic__value.html#a7b113a731815356acb870bfe37b15e1b">as_table</a>().at(<span class="stringliteral">&quot;answer&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(answer.is_integer() &amp;&amp; answer.as_integer(std::nothrow) == 42)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;value is 42&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p >If <code>std::nothrow</code> is passed, the functions are marked as noexcept.</p>
<p >By casting a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> into an array or a table, you can iterate over the elements.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;keys in the top-level table are the following: \n&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [k, v] : data.<a class="code hl_function" href="classtoml_1_1basic__value.html#a7b113a731815356acb870bfe37b15e1b">as_table</a>())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; k &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruits = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>(data, <span class="stringliteral">&quot;fruits&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : fruits.as_array())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; toml::find&lt;std::string&gt;(v, <span class="stringliteral">&quot;name&quot;</span>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The full list of the functions is below.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a> {</div>
<div class="line"><span class="keyword">class </span><a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a> {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">boolean</span>&amp;         <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>()         const&amp;;</div>
<div class="line">    const <a class="code hl_typedef" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">integer</a>&amp;         <a class="code hl_function" href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">as_integer</a>()         const&amp;;</div>
<div class="line">    const <a class="code hl_typedef" href="namespacetoml.html#a54f4b85eab8f0d6e6f0149c5ba338f6a">floating</a>&amp;        <a class="code hl_function" href="classtoml_1_1basic__value.html#a2e3042121a3ecaaf09bbfc7b81c3bb04">as_floating</a>()        const&amp;;</div>
<div class="line">    const <span class="keywordtype">string</span>&amp;          <a class="code hl_function" href="classtoml_1_1basic__value.html#aec4c6cab5956662a54d2ff83db6e32b6">as_string</a>()          const&amp;;</div>
<div class="line">    const offset_datetime&amp; <a class="code hl_function" href="classtoml_1_1basic__value.html#ab31b634452333d71437751b91f4238a1">as_offset_datetime</a>() const&amp;;</div>
<div class="line">    const local_datetime&amp;  <a class="code hl_function" href="classtoml_1_1basic__value.html#a13d6a5211e94af0f3af5c6a5fb69ea46">as_local_datetime</a>()  const&amp;;</div>
<div class="line">    const local_date&amp;      <a class="code hl_function" href="classtoml_1_1basic__value.html#ab1d72b0d89ceb4ccd8fc6d2805ff7dff">as_local_date</a>()      const&amp;;</div>
<div class="line">    const local_time&amp;      <a class="code hl_function" href="classtoml_1_1basic__value.html#af758543d5a6dfe377ecf96c761bcb4b3">as_local_time</a>()      const&amp;;</div>
<div class="line">    const <a class="code hl_typedef" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">array</a>&amp;           <a class="code hl_function" href="classtoml_1_1basic__value.html#a0be5e35d9160ba668fb82846aa31b853">as_array</a>()           const&amp;;</div>
<div class="line">    const <a class="code hl_typedef" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">table</a>&amp;           <a class="code hl_function" href="classtoml_1_1basic__value.html#a7b113a731815356acb870bfe37b15e1b">as_table</a>()           const&amp;;</div>
<div class="line">    <span class="comment">// --------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// non-const version</span></div>
<div class="line">    <span class="keywordtype">boolean</span>&amp;               <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>()         &amp;;</div>
<div class="line">    <span class="comment">// ditto...</span></div>
<div class="line">    <span class="comment">// --------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// rvalue version</span></div>
<div class="line">    <span class="keywordtype">boolean</span>&amp;&amp;              <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>()         &amp;&amp;;</div>
<div class="line">    <span class="comment">// ditto...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// noexcept versions ...</span></div>
<div class="line">    const <span class="keywordtype">boolean</span>&amp;         <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>(const std::nothrow_t&amp;) const&amp; noexcept;</div>
<div class="line">    <span class="keywordtype">boolean</span>&amp;               <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>(const std::nothrow_t&amp;) &amp;      noexcept;</div>
<div class="line">    <span class="keywordtype">boolean</span>&amp;&amp;              <a class="code hl_function" href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">as_boolean</a>(const std::nothrow_t&amp;) &amp;&amp;     noexcept;</div>
<div class="line">    <span class="comment">// ditto...</span></div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a0be5e35d9160ba668fb82846aa31b853"><div class="ttname"><a href="classtoml_1_1basic__value.html#a0be5e35d9160ba668fb82846aa31b853">toml::basic_value::as_array</a></div><div class="ttdeci">array_type const &amp; as_array(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1218</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a13d6a5211e94af0f3af5c6a5fb69ea46"><div class="ttname"><a href="classtoml_1_1basic__value.html#a13d6a5211e94af0f3af5c6a5fb69ea46">toml::basic_value::as_local_datetime</a></div><div class="ttdeci">local_datetime const &amp; as_local_datetime(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1215</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a2e3042121a3ecaaf09bbfc7b81c3bb04"><div class="ttname"><a href="classtoml_1_1basic__value.html#a2e3042121a3ecaaf09bbfc7b81c3bb04">toml::basic_value::as_floating</a></div><div class="ttdeci">floating const &amp; as_floating(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1212</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ab1d72b0d89ceb4ccd8fc6d2805ff7dff"><div class="ttname"><a href="classtoml_1_1basic__value.html#ab1d72b0d89ceb4ccd8fc6d2805ff7dff">toml::basic_value::as_local_date</a></div><div class="ttdeci">local_date const &amp; as_local_date(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1216</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ab31b634452333d71437751b91f4238a1"><div class="ttname"><a href="classtoml_1_1basic__value.html#ab31b634452333d71437751b91f4238a1">toml::basic_value::as_offset_datetime</a></div><div class="ttdeci">offset_datetime const &amp; as_offset_datetime(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1214</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aca975951282724efbfdb52658a4de470"><div class="ttname"><a href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">toml::basic_value::as_integer</a></div><div class="ttdeci">integer const &amp; as_integer(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1211</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ae07b24787a4e58745c6637819905a398"><div class="ttname"><a href="classtoml_1_1basic__value.html#ae07b24787a4e58745c6637819905a398">toml::basic_value::as_boolean</a></div><div class="ttdeci">boolean const &amp; as_boolean(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1210</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aec4c6cab5956662a54d2ff83db6e32b6"><div class="ttname"><a href="classtoml_1_1basic__value.html#aec4c6cab5956662a54d2ff83db6e32b6">toml::basic_value::as_string</a></div><div class="ttdeci">string const &amp; as_string(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1213</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_af758543d5a6dfe377ecf96c761bcb4b3"><div class="ttname"><a href="classtoml_1_1basic__value.html#af758543d5a6dfe377ecf96c761bcb4b3">toml::basic_value::as_local_time</a></div><div class="ttdeci">local_time const &amp; as_local_time(const std::nothrow_t &amp;) const &amp;noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1217</div></div>
<div class="ttc" id="anamespacetoml_html"><div class="ttname"><a href="namespacetoml.html">toml</a></div><div class="ttdef"><b>Definition:</b> test_extended_conversions.cpp:60</div></div>
<div class="ttc" id="anamespacetoml_html_a34e466167cc683c477838accdebb2578"><div class="ttname"><a href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></div><div class="ttdeci">basic_value&lt; TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector &gt; value</div><div class="ttdef"><b>Definition:</b> value.hpp:1754</div></div>
<div class="ttc" id="anamespacetoml_html_a4db748c68f34deac79e0b45535cfb3b6"><div class="ttname"><a href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></div><div class="ttdeci">typename value::array_type array</div><div class="ttdef"><b>Definition:</b> value.hpp:1755</div></div>
<div class="ttc" id="anamespacetoml_html_a54f4b85eab8f0d6e6f0149c5ba338f6a"><div class="ttname"><a href="namespacetoml.html#a54f4b85eab8f0d6e6f0149c5ba338f6a">toml::floating</a></div><div class="ttdeci">double floating</div><div class="ttdef"><b>Definition:</b> types.hpp:31</div></div>
<div class="ttc" id="anamespacetoml_html_af7d788a576baa570efd4793cd5df8ac7"><div class="ttname"><a href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></div><div class="ttdeci">typename value::table_type table</div><div class="ttdef"><b>Definition:</b> value.hpp:1756</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
&lt;tt&gt;at()&lt;/tt&gt;</h2>
<p >You can access to the element of a table and an array by <code><a class="el" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">toml::basic_value::at</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{1,2,3,4,5};</div>
<div class="line">std::cout &lt;&lt; v.<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(2).<a class="code hl_function" href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">as_integer</a>() &lt;&lt; std::endl; <span class="comment">// 3</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{{<span class="stringliteral">&quot;foo&quot;</span>, 42}, {<span class="stringliteral">&quot;bar&quot;</span>, 3.14}};</div>
<div class="line">std::cout &lt;&lt; v.<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(<span class="stringliteral">&quot;foo&quot;</span>).<a class="code hl_function" href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">as_integer</a>() &lt;&lt; std::endl; <span class="comment">// 42</span></div>
</div><!-- fragment --><p >If an invalid key (integer for a table, string for an array), it throws <code><a class="el" href="structtoml_1_1type__error.html">toml::type_error</a></code> for the conversion. If the provided key is out-of-range, it throws <code>std::out_of_range</code>.</p>
<p >Note that, although <code>std::string</code> has <code>at()</code> member function, <code><a class="el" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">toml::value::at</a></code> throws if the contained type is a string. Because <code>std::string</code> does not contain <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
&lt;tt&gt;operator[]&lt;/tt&gt;</h2>
<p >You can also access to the element of a table and an array by <code>toml::basic_value::operator[]</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{1,2,3,4,5};</div>
<div class="line">std::cout &lt;&lt; v[2].<a class="code hl_function" href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">as_integer</a>() &lt;&lt; std::endl; <span class="comment">// 3</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{{<span class="stringliteral">&quot;foo&quot;</span>, 42}, {<span class="stringliteral">&quot;bar&quot;</span>, 3.14}};</div>
<div class="line">std::cout &lt;&lt; v[<span class="stringliteral">&quot;foo&quot;</span>].<a class="code hl_function" href="classtoml_1_1basic__value.html#aca975951282724efbfdb52658a4de470">as_integer</a>() &lt;&lt; std::endl; <span class="comment">// 42</span></div>
</div><!-- fragment --><p >When you access to a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> that is not initialized yet via <code>operator[](const std::string&amp;)</code>, the <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> will be a table, just like the <code>std::map</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v; <span class="comment">// not initialized as a table.</span></div>
<div class="line">v[<span class="stringliteral">&quot;foo&quot;</span>] = 42; <span class="comment">// OK. `v` will be a table.</span></div>
</div><!-- fragment --><p >Contrary, if you access to a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> that contains an array via <code>operator[]</code>, it does not check anything. It converts <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> without type check and then access to the n-th element without boundary check, just like the <code>std::vector::operator[]</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v; <span class="comment">// not initialized as an array</span></div>
<div class="line">v[2] = 42;     <span class="comment">// error! UB</span></div>
</div><!-- fragment --><p >Please make sure that the <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> has an array inside when you access to its element via <code>operator[]</code>.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Checking value type</h1>
<p >You can check the type of a value by <code>is_xxx</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v = <span class="comment">/* ... */</span>;</div>
<div class="line"><span class="keywordflow">if</span>(v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a0c32f842bc29c7788a0b58a1bc436378">is_integer</a>())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;value is an integer&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a0c32f842bc29c7788a0b58a1bc436378"><div class="ttname"><a href="classtoml_1_1basic__value.html#a0c32f842bc29c7788a0b58a1bc436378">toml::basic_value::is_integer</a></div><div class="ttdeci">bool is_integer() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1167</div></div>
</div><!-- fragment --><p >The complete list of the functions is below.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a> {</div>
<div class="line"><span class="keyword">class </span><a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a> {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a480543865f432dbc35568f954196e2e2">is_boolean</a>()         const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a0c32f842bc29c7788a0b58a1bc436378">is_integer</a>()         const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#aa3ffdc3a4df542fc4bc140fa74b21e59">is_floating</a>()        const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#aa7484eeb07b564c7ea8b9728995c60c0">is_string</a>()          const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a9f593a66f7919c9e4f3c0e00a93cec88">is_offset_datetime</a>() const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a74e4b24b291fbcb2581a5501c14a7712">is_local_datetime</a>()  const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#abb9f5306c085b267824f5f32ed04e1b5">is_local_date</a>()      const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#ada3bd713ab6e0aba5ed3e177417450d4">is_local_time</a>()      const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a8c80028f02dae5fce11fa2de46e5a202">is_array</a>()           const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#a93c66a2b01a1022e57fc21ad5a781c1a">is_table</a>()           const noexcept;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classtoml_1_1basic__value.html#aa9e0adf3eaf980cd7ec1224fa675280c">is_uninitialized</a>()   const noexcept;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a480543865f432dbc35568f954196e2e2"><div class="ttname"><a href="classtoml_1_1basic__value.html#a480543865f432dbc35568f954196e2e2">toml::basic_value::is_boolean</a></div><div class="ttdeci">bool is_boolean() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1166</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a74e4b24b291fbcb2581a5501c14a7712"><div class="ttname"><a href="classtoml_1_1basic__value.html#a74e4b24b291fbcb2581a5501c14a7712">toml::basic_value::is_local_datetime</a></div><div class="ttdeci">bool is_local_datetime() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1171</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a8c80028f02dae5fce11fa2de46e5a202"><div class="ttname"><a href="classtoml_1_1basic__value.html#a8c80028f02dae5fce11fa2de46e5a202">toml::basic_value::is_array</a></div><div class="ttdeci">bool is_array() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1174</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a93c66a2b01a1022e57fc21ad5a781c1a"><div class="ttname"><a href="classtoml_1_1basic__value.html#a93c66a2b01a1022e57fc21ad5a781c1a">toml::basic_value::is_table</a></div><div class="ttdeci">bool is_table() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1175</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a9f593a66f7919c9e4f3c0e00a93cec88"><div class="ttname"><a href="classtoml_1_1basic__value.html#a9f593a66f7919c9e4f3c0e00a93cec88">toml::basic_value::is_offset_datetime</a></div><div class="ttdeci">bool is_offset_datetime() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1170</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aa3ffdc3a4df542fc4bc140fa74b21e59"><div class="ttname"><a href="classtoml_1_1basic__value.html#aa3ffdc3a4df542fc4bc140fa74b21e59">toml::basic_value::is_floating</a></div><div class="ttdeci">bool is_floating() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1168</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aa7484eeb07b564c7ea8b9728995c60c0"><div class="ttname"><a href="classtoml_1_1basic__value.html#aa7484eeb07b564c7ea8b9728995c60c0">toml::basic_value::is_string</a></div><div class="ttdeci">bool is_string() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1169</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_aa9e0adf3eaf980cd7ec1224fa675280c"><div class="ttname"><a href="classtoml_1_1basic__value.html#aa9e0adf3eaf980cd7ec1224fa675280c">toml::basic_value::is_uninitialized</a></div><div class="ttdeci">bool is_uninitialized() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1165</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_abb9f5306c085b267824f5f32ed04e1b5"><div class="ttname"><a href="classtoml_1_1basic__value.html#abb9f5306c085b267824f5f32ed04e1b5">toml::basic_value::is_local_date</a></div><div class="ttdeci">bool is_local_date() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1172</div></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ada3bd713ab6e0aba5ed3e177417450d4"><div class="ttname"><a href="classtoml_1_1basic__value.html#ada3bd713ab6e0aba5ed3e177417450d4">toml::basic_value::is_local_time</a></div><div class="ttdeci">bool is_local_time() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1173</div></div>
</div><!-- fragment --><p >Also, you can get <code>enum class value_t</code> from <code><a class="el" href="classtoml_1_1basic__value.html#ab2dc908989dc98538bfaa7107f9a3fa3">toml::value::type()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span>(data.<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(<span class="stringliteral">&quot;something&quot;</span>).<a class="code hl_function" href="classtoml_1_1basic__value.html#ab2dc908989dc98538bfaa7107f9a3fa3">type</a>())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8">toml::value_t::integer</a>:  <span class="comment">/*do some stuff*/</span> ; <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17">toml::value_t::floating</a>: <span class="comment">/*do some stuff*/</span> ; <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21">toml::value_t::string</a> :  <span class="comment">/*do some stuff*/</span> ; <span class="keywordflow">break</span>;</div>
<div class="line">    default : <span class="keywordflow">throw</span> std::runtime_error(</div>
<div class="line">        <span class="stringliteral">&quot;unexpected type : &quot;</span> + <a class="code hl_function" href="namespacetoml.html#aaf1e28f553918a844120bf20679de5c7">toml::stringize</a>(data.<a class="code hl_function" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">at</a>(<span class="stringliteral">&quot;something&quot;</span>).<a class="code hl_function" href="classtoml_1_1basic__value.html#ab2dc908989dc98538bfaa7107f9a3fa3">type</a>()));</div>
<div class="line">}</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_ab2dc908989dc98538bfaa7107f9a3fa3"><div class="ttname"><a href="classtoml_1_1basic__value.html#ab2dc908989dc98538bfaa7107f9a3fa3">toml::basic_value::type</a></div><div class="ttdeci">value_t type() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1177</div></div>
<div class="ttc" id="anamespacetoml_html_a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8"><div class="ttname"><a href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8">toml::value_t::integer</a></div><div class="ttdeci">@ integer</div></div>
<div class="ttc" id="anamespacetoml_html_a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17"><div class="ttname"><a href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17">toml::value_t::floating</a></div><div class="ttdeci">@ floating</div></div>
<div class="ttc" id="anamespacetoml_html_a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21"><div class="ttname"><a href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21">toml::value_t::string</a></div><div class="ttdeci">@ string</div></div>
<div class="ttc" id="anamespacetoml_html_aaf1e28f553918a844120bf20679de5c7"><div class="ttname"><a href="namespacetoml.html#aaf1e28f553918a844120bf20679de5c7">toml::stringize</a></div><div class="ttdeci">std::basic_string&lt; charT, traits, alloc &gt; stringize(value_t t)</div><div class="ttdef"><b>Definition:</b> types.hpp:102</div></div>
</div><!-- fragment --><p >The complete list of the <code>enum</code>s can be found in the section underlying types.</p>
<p >The <code>enum</code>s can be used as a parameter of <code><a class="el" href="classtoml_1_1basic__value.html#a3ab8d9b76f8236f194ad9e3036c11d41">toml::value::is</a></code> function like the following.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v = <span class="comment">/* ... */</span>;</div>
<div class="line"><span class="keywordflow">if</span>(v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a3ab8d9b76f8236f194ad9e3036c11d41">is</a>(<a class="code hl_enumvalue" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27">toml::value_t::boolean</a>)) <span class="comment">// ...</span></div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a3ab8d9b76f8236f194ad9e3036c11d41"><div class="ttname"><a href="classtoml_1_1basic__value.html#a3ab8d9b76f8236f194ad9e3036c11d41">toml::basic_value::is</a></div><div class="ttdeci">bool is() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1159</div></div>
<div class="ttc" id="anamespacetoml_html_a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27"><div class="ttname"><a href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27">toml::value_t::boolean</a></div><div class="ttdeci">@ boolean</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
More about conversion</h1>
<p >Since <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> internally uses <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code>, all the following examples work with both <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> and <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Converting an array</h2>
<p >You can get any kind of <code>container</code> class from a <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> except for <code>map</code>-like classes.</p>
<div class="fragment"><div class="line">// # sample.toml</div>
<div class="line">// numbers = [1,2,3]</div>
<div class="line"> </div>
<div class="line">const auto numbers = toml::find(data, &quot;numbers&quot;);</div>
<div class="line"> </div>
<div class="line">const auto vc  = toml::get&lt;std::vector&lt;int&gt;  &gt;(numbers);</div>
<div class="line">const auto ls  = toml::get&lt;std::list&lt;int&gt;    &gt;(numbers);</div>
<div class="line">const auto dq  = toml::get&lt;std::deque&lt;int&gt;   &gt;(numbers);</div>
<div class="line">const auto ar  = toml::get&lt;std::array&lt;int, 3&gt;&gt;(numbers);</div>
<div class="line">// if the size of data.at(&quot;numbers&quot;) is larger than that of std::array,</div>
<div class="line">// it will throw toml::type_error because std::array is not resizable.</div>
</div><!-- fragment --><p >Surprisingly, you can convert <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> into <code>std::pair</code> and <code>std::tuple</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// numbers = [1,2,3]</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tp = toml::get&lt;std::tuple&lt;short, int, unsigned int&gt;&gt;(numbers);</div>
</div><!-- fragment --><p >This functionality is helpful when you have a toml file like the following.</p>
<div class="fragment"><div class="line">array_of_arrays = [[1, 2, 3], [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]] # toml allows this</div>
</div><!-- fragment --><p >What is the corresponding C++ type? Obviously, it is a <code>std::pair</code> of <code>std::vector</code>s.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> array_of_arrays = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>(data, <span class="stringliteral">&quot;array_of_arrays&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aofa = <a class="code hl_function" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>&lt;</div>
<div class="line">    std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;std::string&gt;&gt;</div>
<div class="line">    &gt;(array_of_arrays);</div>
<div class="ttc" id="anamespacetoml_html_a2e4b27fae0d9dc6b824e77b12112f313"><div class="ttname"><a href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></div><div class="ttdeci">detail::enable_if_t&lt; detail::is_exact_toml_type&lt; T, basic_value&lt; C, M, V &gt; &gt;::value, T &gt; &amp; get(basic_value&lt; C, M, V &gt; &amp;v)</div><div class="ttdef"><b>Definition:</b> get.hpp:20</div></div>
</div><!-- fragment --><p >If you don't know the type of the elements, you can use <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code>, which is a <code>std::vector</code> of <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, instead.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> a_of_a = toml::get&lt;toml::array&gt;(array_of_arrays);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> first  = toml::get&lt;std::vector&lt;int&gt;&gt;(a_of_a.at(0));</div>
</div><!-- fragment --><p >You can change the implementation of <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> with <code>std::deque</code> or some other array-like container. See Customizing containers for detail.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Converting a table</h2>
<p >When all the values of the table have the same type, toml11 allows you to convert a <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> to a <code>map</code> that contains the convertible type.</p>
<div class="fragment"><div class="line">[tab]</div>
<div class="line">key1 = &quot;foo&quot; # all the values are</div>
<div class="line">key2 = &quot;bar&quot; # toml String</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tab = toml::find&lt;std::map&lt;std::string, std::string&gt;&gt;(data, <span class="stringliteral">&quot;tab&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; tab[<span class="stringliteral">&quot;key1&quot;</span>] &lt;&lt; std::endl; <span class="comment">// foo</span></div>
<div class="line">std::cout &lt;&lt; tab[<span class="stringliteral">&quot;key2&quot;</span>] &lt;&lt; std::endl; <span class="comment">// bar</span></div>
</div><!-- fragment --><p >But since <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> is just an alias of <code>std::unordered_map&lt;<a class="el" href="namespacetoml.html#ab00c292fbb2e761ef69fdafd6b813348">toml::key</a>, <a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>&gt;</code>, normally you don't need to convert it because it has all the functionalities that <code>std::unordered_map</code> has (e.g. <code>operator[]</code>, <code>count</code>, and <code>find</code>). In most cases <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> is sufficient.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a> tab = toml::get&lt;toml::table&gt;(data);</div>
<div class="line"><span class="keywordflow">if</span>(data.count(<span class="stringliteral">&quot;title&quot;</span>) != 0)</div>
<div class="line">{</div>
<div class="line">    data[<span class="stringliteral">&quot;title&quot;</span>] = std::string(<span class="stringliteral">&quot;TOML example&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p >You can change the implementation of <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> with <code>std::map</code> or some other map-like container. See Customizing containers for detail.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Getting an array of tables</h2>
<p >An array of tables is just an array of tables. You can get it in completely the same way as the other arrays and tables.</p>
<div class="fragment"><div class="line"># sample.toml</div>
<div class="line">array_of_inline_tables = [{key = &quot;value1&quot;}, {key = &quot;value2&quot;}, {key = &quot;value3&quot;}]</div>
<div class="line"> </div>
<div class="line">[[array_of_tables]]</div>
<div class="line">key = &quot;value4&quot;</div>
<div class="line">[[array_of_tables]]</div>
<div class="line">key = &quot;value5&quot;</div>
<div class="line">[[array_of_tables]]</div>
<div class="line">key = &quot;value6&quot;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aot1 = toml::find&lt;std::vector&lt;toml::table&gt;&gt;(data, <span class="stringliteral">&quot;array_of_inline_tables&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aot2 = toml::find&lt;std::vector&lt;toml::table&gt;&gt;(data, <span class="stringliteral">&quot;array_of_tables&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Cost of conversion</h2>
<p >Although conversion through <code>toml::(get|find)</code> is convenient, it has additional copy-cost because it copies data contained in <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> to the user-specified type. Of course in some cases this overhead is not ignorable.</p>
<div class="fragment"><div class="line"><span class="comment">// the following code constructs a std::vector.</span></div>
<div class="line"><span class="comment">// it requires heap allocation for vector and element conversion.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_typedef" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">array</a> = toml::find&lt;std::vector&lt;int&gt;&gt;(data, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p >By passing the exact types, <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> returns reference that has no overhead.</p>
<div class="fragment"><div class="line">const auto&amp; tab     = toml::find&lt;toml::table&gt;(data, &quot;tab&quot;);</div>
<div class="line">const auto&amp; numbers = toml::find&lt;toml::array&gt;(data, &quot;numbers&quot;);</div>
</div><!-- fragment --><p >Also, <code>as_xxx</code> are zero-overhead because they always return a reference.</p>
<div class="fragment"><div class="line">const auto&amp; tab     = toml::find(data, &quot;tab&quot;    ).as_table();</div>
<div class="line">const auto&amp; numbers = toml::find(data, &quot;numbers&quot;).as_array();</div>
</div><!-- fragment --><p >In this case you need to call <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> each time you access to the element of <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> because <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> is an array of <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; num0 = toml::get&lt;toml::integer&gt;(numbers.at(0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; num1 = toml::get&lt;toml::integer&gt;(numbers.at(1));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; num2 = toml::get&lt;toml::integer&gt;(numbers.at(2));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Converting datetime and its variants</h2>
<p >TOML v0.5.0 has 4 different datetime objects, <code>local_date</code>, <code>local_time</code>, <code>local_datetime</code>, and <code>offset_datetime</code>.</p>
<p >Since <code>local_date</code>, <code>local_datetime</code>, and <code>offset_datetime</code> represent a time point, you can convert them to <code>std::chrono::system_clock::time_point</code>.</p>
<p >Contrary, <code>local_time</code> does not represents a time point because they lack a date information, but it can be converted to <code>std::chrono::duration</code> that represents a duration from the beginning of the day, <code>00:00:00.000</code>.</p>
<div class="fragment"><div class="line"># sample.toml</div>
<div class="line">date = 2018-12-23</div>
<div class="line">time = 12:30:00</div>
<div class="line">l_dt = 2018-12-23T12:30:00</div>
<div class="line">o_dt = 2018-12-23T12:30:00+09:30</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;sample.toml&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> date = toml::get&lt;std::chrono::system_clock::time_point&gt;(data.at(<span class="stringliteral">&quot;date&quot;</span>));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> l_dt = toml::get&lt;std::chrono::system_clock::time_point&gt;(data.at(<span class="stringliteral">&quot;l_dt&quot;</span>));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> o_dt = toml::get&lt;std::chrono::system_clock::time_point&gt;(data.at(<span class="stringliteral">&quot;o_dt&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> time = toml::get&lt;std::chrono::minutes&gt;(data.at(<span class="stringliteral">&quot;time&quot;</span>)); <span class="comment">// 12 * 60 + 30 min</span></div>
</div><!-- fragment --><p ><code>local_date</code> and <code>local_datetime</code> are assumed to be in the local timezone when they are converted into <code>time_point</code>. On the other hand, <code>offset_datetime</code> only uses the offset part of the data and it does not take local timezone into account.</p>
<p >To contain datetime data, toml11 defines its own datetime types. For more detail, you can see the definitions in <a href="toml/datetime.hpp">toml/datetime.hpp</a>.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Getting with a fallback</h1>
<p ><code><a class="el" href="namespacetoml.html#a34fb7cea6c5ed3988dd2d3944bfd6b2a">toml::find_or</a></code> returns a default value if the value is not found or has a different type.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> num  = <a class="code hl_function" href="namespacetoml.html#a34fb7cea6c5ed3988dd2d3944bfd6b2a">toml::find_or</a>(data, <span class="stringliteral">&quot;num&quot;</span>, 42);</div>
<div class="ttc" id="anamespacetoml_html_a34fb7cea6c5ed3988dd2d3944bfd6b2a"><div class="ttname"><a href="namespacetoml.html#a34fb7cea6c5ed3988dd2d3944bfd6b2a">toml::find_or</a></div><div class="ttdeci">basic_value&lt; C, M, V &gt; const &amp; find_or(const basic_value&lt; C, M, V &gt; &amp;v, const key &amp;ky, const basic_value&lt; C, M, V &gt; &amp;opt)</div><div class="ttdef"><b>Definition:</b> get.hpp:902</div></div>
</div><!-- fragment --><p >It works recursively if you pass several keys for subtables. In that case, the last argument is considered to be the optional value. All other arguments between <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> and the optinoal value are considered as keys.</p>
<div class="fragment"><div class="line"><span class="comment">// [fruit.physical]</span></div>
<div class="line"><span class="comment">// color = &quot;red&quot;</span></div>
<div class="line"><span class="keyword">auto</span> data  = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;fruit.toml&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> color = <a class="code hl_function" href="namespacetoml.html#a34fb7cea6c5ed3988dd2d3944bfd6b2a">toml::find_or</a>(data, <span class="stringliteral">&quot;fruit&quot;</span>, <span class="stringliteral">&quot;physical&quot;</span>, <span class="stringliteral">&quot;color&quot;</span>, <span class="stringliteral">&quot;red&quot;</span>);</div>
<div class="line"><span class="comment">//                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^</span></div>
<div class="line"><span class="comment">//                               arguments                     optional value</span></div>
</div><!-- fragment --><p >Also, <code><a class="el" href="namespacetoml.html#aee831fac191301c5d2821d231881fb5c">toml::get_or</a></code> returns a default value if <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>&lt;T&gt;</code> failed.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// v contains String</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a> = <a class="code hl_function" href="namespacetoml.html#aee831fac191301c5d2821d231881fb5c">toml::get_or</a>(v, 42); <span class="comment">// conversion fails. it returns 42.</span></div>
<div class="ttc" id="anamespacetoml_html_aee831fac191301c5d2821d231881fb5c"><div class="ttname"><a href="namespacetoml.html#aee831fac191301c5d2821d231881fb5c">toml::get_or</a></div><div class="ttdeci">basic_value&lt; C, M, V &gt; const &amp; get_or(const basic_value&lt; C, M, V &gt; &amp;v, const basic_value&lt; C, M, V &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> get.hpp:737</div></div>
</div><!-- fragment --><p >These functions automatically deduce what type you want to get from the default value you passed.</p>
<p >To get a reference through this function, take care about the default value.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// v contains String</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a>&amp; i = <a class="code hl_function" href="namespacetoml.html#aee831fac191301c5d2821d231881fb5c">toml::get_or</a>(v, 42); <span class="comment">// does not work because binding `42`</span></div>
<div class="line">                                        <span class="comment">// to `integer&amp;` is invalid</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a> opt = 42;</div>
<div class="line"><a class="code hl_typedef" href="namespacetoml.html#ad9642acd2a70ea10c7c6c1b53a3caac9">toml::integer</a>&amp; i = <a class="code hl_function" href="namespacetoml.html#aee831fac191301c5d2821d231881fb5c">toml::get_or</a>(v, opt); <span class="comment">// this works.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Expecting conversion</h1>
<p >By using <code><a class="el" href="namespacetoml.html#a303d95485a58e3396a677b8e852b6481">toml::expect</a></code>, you will get your expected value or an error message without throwing <code><a class="el" href="structtoml_1_1type__error.html">toml::type_error</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a> = toml::expect&lt;std::string&gt;(data.at(<span class="stringliteral">&quot;title&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a>.is_ok()) {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a>.unwrap() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a>.unwrap_err() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Also, you can pass a function object to modify the expected value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">value</a> = toml::expect&lt;int&gt;(data.at(<span class="stringliteral">&quot;number&quot;</span>))</div>
<div class="line">    .map(<span class="comment">// function that receives expected type (here, int)</span></div>
<div class="line">    [](<span class="keyword">const</span> <span class="keywordtype">int</span> number) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">        <span class="keywordflow">return</span> number * 1.5 + 1.0;</div>
<div class="line">    }).unwrap_or(<span class="comment">/*default value =*/</span> 3.14);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Visiting a toml::value</h1>
<p >toml11 provides <code><a class="el" href="namespacetoml.html#afdb46445ef5dd69d0f3405f62b0d76b5">toml::visit</a></code> to apply a function to <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> in the same way as <code>std::variant</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(3.14);</div>
<div class="line"><a class="code hl_function" href="namespacetoml.html#afdb46445ef5dd69d0f3405f62b0d76b5">toml::visit</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</div>
<div class="line">    }, v);</div>
<div class="ttc" id="anamespacetoml_html_afdb46445ef5dd69d0f3405f62b0d76b5"><div class="ttname"><a href="namespacetoml.html#afdb46445ef5dd69d0f3405f62b0d76b5">toml::visit</a></div><div class="ttdeci">detail::return_type_of_t&lt; Visitor, const toml::boolean &amp; &gt; visit(Visitor &amp;&amp;visitor, const toml::basic_value&lt; C, T, A &gt; &amp;v)</div><div class="ttdef"><b>Definition:</b> value.hpp:1965</div></div>
</div><!-- fragment --><p >The function object that would be passed to <code><a class="el" href="namespacetoml.html#afdb46445ef5dd69d0f3405f62b0d76b5">toml::visit</a></code> must be able to receive all the possible TOML types. Also, the result types should be the same each other.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Constructing a toml::value</h1>
<p ><code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> can be constructed in various ways.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="keyword">true</span>);     <span class="comment">// boolean</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(42);       <span class="comment">// integer</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(3.14);     <span class="comment">// floating</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="stringliteral">&quot;foobar&quot;</span>); <span class="comment">// string</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_struct" href="structtoml_1_1local__date.html">toml::local_date</a>(2019, <a class="code hl_enumvalue" href="namespacetoml.html#a89509f5839cddbb6cc3205611e198ca5a6d7215c4b3bc4716d026ac46c6d9ae64">toml::month_t::Apr</a>, 1)); <span class="comment">// date</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{1, 2, 3, 4, 5};                                 <span class="comment">// array</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{{<span class="stringliteral">&quot;foo&quot;</span>, 42}, {<span class="stringliteral">&quot;bar&quot;</span>, 3.14}, {<span class="stringliteral">&quot;baz&quot;</span>, <span class="stringliteral">&quot;qux&quot;</span>}};    <span class="comment">// table</span></div>
<div class="ttc" id="anamespacetoml_html_a89509f5839cddbb6cc3205611e198ca5a6d7215c4b3bc4716d026ac46c6d9ae64"><div class="ttname"><a href="namespacetoml.html#a89509f5839cddbb6cc3205611e198ca5a6d7215c4b3bc4716d026ac46c6d9ae64">toml::month_t::Apr</a></div><div class="ttdeci">@ Apr</div></div>
<div class="ttc" id="astructtoml_1_1local__date_html"><div class="ttname"><a href="structtoml_1_1local__date.html">toml::local_date</a></div><div class="ttdef"><b>Definition:</b> datetime.hpp:87</div></div>
</div><!-- fragment --><p >When constructing a string, you can choose to use either literal or basic string. By default, it will be a basic string.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="stringliteral">&quot;foobar&quot;</span>, <a class="code hl_enumvalue" href="namespacetoml.html#a54c05bb4b385f96d45e3807a92c1d19aaf17aaabc20bfe045075927934fed52d2">toml::string_t::basic</a>  );</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<span class="stringliteral">&quot;foobar&quot;</span>, <a class="code hl_enumvalue" href="namespacetoml.html#a54c05bb4b385f96d45e3807a92c1d19aaf0d674f1e0ed4292267f149c5983db02">toml::string_t::literal</a>);</div>
<div class="ttc" id="anamespacetoml_html_a54c05bb4b385f96d45e3807a92c1d19aaf0d674f1e0ed4292267f149c5983db02"><div class="ttname"><a href="namespacetoml.html#a54c05bb4b385f96d45e3807a92c1d19aaf0d674f1e0ed4292267f149c5983db02">toml::string_t::literal</a></div><div class="ttdeci">@ literal</div></div>
<div class="ttc" id="anamespacetoml_html_a54c05bb4b385f96d45e3807a92c1d19aaf17aaabc20bfe045075927934fed52d2"><div class="ttname"><a href="namespacetoml.html#a54c05bb4b385f96d45e3807a92c1d19aaf17aaabc20bfe045075927934fed52d2">toml::string_t::basic</a></div><div class="ttdeci">@ basic</div></div>
</div><!-- fragment --><p >Datetime objects can be constructed from <code>std::tm</code> and <code>std::chrono::system_clock::time_point</code>. But you need to specify what type you use to avoid ambiguity.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> now = std::chrono::system_clock::now();</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_struct" href="structtoml_1_1local__date.html">toml::local_date</a>(now));</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_struct" href="structtoml_1_1local__datetime.html">toml::local_datetime</a>(now));</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_struct" href="structtoml_1_1offset__datetime.html">toml::offset_datetime</a>(now));</div>
<div class="ttc" id="astructtoml_1_1local__datetime_html"><div class="ttname"><a href="structtoml_1_1local__datetime.html">toml::local_datetime</a></div><div class="ttdef"><b>Definition:</b> datetime.hpp:366</div></div>
<div class="ttc" id="astructtoml_1_1offset__datetime_html"><div class="ttname"><a href="structtoml_1_1offset__datetime.html">toml::offset_datetime</a></div><div class="ttdef"><b>Definition:</b> datetime.hpp:480</div></div>
</div><!-- fragment --><p >Since local time is not equivalent to a time point, because it lacks date information, it will be constructed from <code>std::chrono::duration</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_struct" href="structtoml_1_1local__time.html">toml::local_time</a>(std::chrono::hours(10)));</div>
<div class="ttc" id="astructtoml_1_1local__time_html"><div class="ttname"><a href="structtoml_1_1local__time.html">toml::local_time</a></div><div class="ttdef"><b>Definition:</b> datetime.hpp:183</div></div>
</div><!-- fragment --><p >You can construct an array object not only from <code>initializer_list</code>, but also from STL containers. In that case, the element type must be convertible to <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{1,2,3,4,5};</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(vec);</div>
</div><!-- fragment --><p >When you construct an array value, all the elements of <code>initializer_list</code> must be convertible into <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<p >If a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> has an array, you can <code>push_back</code> an element in it.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{1,2,3,4,5};</div>
<div class="line">v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a5070496463735ce25ae8765ab5cb90ad">push_back</a>(6);</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a5070496463735ce25ae8765ab5cb90ad"><div class="ttname"><a href="classtoml_1_1basic__value.html#a5070496463735ce25ae8765ab5cb90ad">toml::basic_value::push_back</a></div><div class="ttdeci">void push_back(const value_type &amp;x)</div><div class="ttdef"><b>Definition:</b> value.hpp:1621</div></div>
</div><!-- fragment --><p ><code>emplace_back</code> also works.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Preserving comments</h1>
<p >toml11 v3 or later allows you yo choose whether comments are preserved or not via template parameter</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data1 = toml::parse&lt;toml::discard_comments &gt;(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data2 = toml::parse&lt;toml::preserve_comments&gt;(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
</div><!-- fragment --><p >or macro definition.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define TOML11_PRESERVE_COMMENTS_BY_DEFAULT</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="toml_8hpp.html">toml11/toml.hpp</a>&gt;</span></div>
</div><!-- fragment --><p >This feature is controlled by template parameter in <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;...&gt;</code>. <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> is an alias of <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;...&gt;</code>.</p>
<p >If template parameter is explicitly specified, the return value of <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> will be <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;<a class="el" href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a>&gt;</code>. If the macro is defined, the alias <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> will be <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;<a class="el" href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a>&gt;</code>.</p>
<p >Comments related to a value can be obtained by <code><a class="el" href="classtoml_1_1basic__value.html#a02d80ca9d8d19ac48b88464478f51550">toml::value::comments()</a></code>. The return value has the same interface as <code>std::vector&lt;std::string&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; com = v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a8f30566aaf9f5bdbaeaea4f177b16ff3">comments</a>();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : com)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a8f30566aaf9f5bdbaeaea4f177b16ff3"><div class="ttname"><a href="classtoml_1_1basic__value.html#a8f30566aaf9f5bdbaeaea4f177b16ff3">toml::basic_value::comments</a></div><div class="ttdeci">comment_type const &amp; comments() const noexcept</div><div class="ttdef"><b>Definition:</b> value.hpp:1706</div></div>
</div><!-- fragment --><p >Comments just before and just after (within the same line) a value are kept in a value.</p>
<div class="fragment"><div class="line"># this is a comment for v1.</div>
<div class="line">v1 = &quot;foo&quot;</div>
<div class="line"> </div>
<div class="line">v2 = &quot;bar&quot; # this is a comment for v2.</div>
<div class="line"># Note that this comment is NOT a comment for v2.</div>
<div class="line"> </div>
<div class="line"># this comment is not related to any value</div>
<div class="line"># because there are empty lines between v3.</div>
<div class="line"># this comment will be ignored even if you set `preserve_comments`.</div>
<div class="line"> </div>
<div class="line"># this is a comment for v3</div>
<div class="line"># this is also a comment for v3.</div>
<div class="line">v3 = &quot;baz&quot; # ditto.</div>
</div><!-- fragment --><p >Each comment line becomes one element of a <code>std::vector</code>.</p>
<p >Hash signs will be removed, but spaces after hash sign will not be removed.</p>
<div class="fragment"><div class="line">v1.comments().at(0) == <span class="stringliteral">&quot; this is a comment for v1.&quot;</span>s;</div>
<div class="line"> </div>
<div class="line">v2.comments().at(1) == <span class="stringliteral">&quot; this is a comment for v1.&quot;</span>s;</div>
<div class="line"> </div>
<div class="line">v3.comments().at(0) == <span class="stringliteral">&quot; this is a comment for v3.&quot;</span>s;</div>
<div class="line">v3.comments().at(1) == <span class="stringliteral">&quot; this is also a comment for v3.&quot;</span>s;</div>
<div class="line">v3.comments().at(2) == <span class="stringliteral">&quot; ditto.&quot;</span>s;</div>
</div><!-- fragment --><p >Note that a comment just after an opening brace of an array will not be a comment for the array.</p>
<div class="fragment"><div class="line"># this is a comment for a.</div>
<div class="line">a = [ # this is not a comment for a. this will be ignored.</div>
<div class="line">  1, 2, 3,</div>
<div class="line">  # this is a comment for `42`.</div>
<div class="line">  42, # this is also a comment for `42`.</div>
<div class="line">  5</div>
<div class="line">] # this is a comment for a.</div>
</div><!-- fragment --><p >You can also append and modify comments. The interfaces are the same as <code>std::vector&lt;std::string&gt;</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;toml::preserve_comments&gt;</a> v(42);</div>
<div class="line">v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a8f30566aaf9f5bdbaeaea4f177b16ff3">comments</a>().push_back(<span class="stringliteral">&quot; add this comment.&quot;</span>);</div>
<div class="line"><span class="comment">// # add this comment.</span></div>
<div class="line"><span class="comment">// i = 42</span></div>
</div><!-- fragment --><p >Also, you can pass a <code>std::vector&lt;std::string&gt;</code> when constructing a <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;<a class="el" href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a>&gt;</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; comments{<span class="stringliteral">&quot;comment 1&quot;</span>, <span class="stringliteral">&quot;comment 2&quot;</span>};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;toml::preserve_comments&gt;</a> v1(42, std::move(comments));</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;toml::preserve_comments&gt;</a> v2(42, {<span class="stringliteral">&quot;comment 1&quot;</span>, <span class="stringliteral">&quot;comment 2&quot;</span>});</div>
</div><!-- fragment --><p >When <code><a class="el" href="structtoml_1_1discard__comments.html">toml::discard_comments</a></code> is chosen, comments will not be contained in a value. <code>value::comments()</code> will always be kept empty. All the modification on comments would be ignored. All the element access in a <code>discard_comments</code> causes the same error as accessing an element of an empty <code>std::vector</code>.</p>
<p >The comments will also be serialized. If comments exist, those comments will be added just before the values.</p>
<p ><b>NOTE</b>: Result types from <code>toml::parse(...)</code> and <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>&lt;<a class="el" href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a>&gt;(...)</code> are different.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Customizing containers</h1>
<p >Actually, <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a></code> has 3 template arguments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comment, <span class="comment">// discard/preserve_comment</span></div>
<div class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>Table = std::unordered_map,</div>
<div class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>Array = std::vector&gt;</div>
<div class="line"><span class="keyword">class </span>basic_value;</div>
</div><!-- fragment --><p >This enables you to change the containers used inside. E.g. you can use <code>std::map</code> to contain a table object instead of <code>std::unordered_map</code>. And also can use <code>std::deque</code> as a array object instead of <code>std::vector</code>.</p>
<p >You can set these parameters while calling <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a>, std::map, std::deque</div>
<div class="line">    &gt;(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="ttc" id="astructtoml_1_1preserve__comments_html"><div class="ttname"><a href="structtoml_1_1preserve__comments.html">toml::preserve_comments</a></div><div class="ttdef"><b>Definition:</b> comments.hpp:37</div></div>
</div><!-- fragment --><p >Needless to say, the result types from <code>toml::parse(...)</code> and <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>&lt;Com, Map, Cont&gt;(...)</code> are different (unless you specify the same types as default).</p>
<p >Note that, since <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> and <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> is an alias for a table and an array of a default <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, so it is different from the types actually contained in a <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a></code> when you customize containers. To get the actual type in a generic way, use <code>typename toml::basic_type&lt;C, T, A&gt;::table_type</code> and <code>typename toml::basic_type&lt;C, T, A&gt;::array_type</code>.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
TOML literal</h1>
<p >toml11 supports <code>"..."_toml</code> literal. It accept both a bare value and a file content.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacetoml_1_1literals_1_1toml__literals.html">toml::literals::toml_literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `_toml` can convert a bare value without key</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v = u8<span class="stringliteral">&quot;0xDEADBEEF&quot;</span>_toml;</div>
<div class="line"><span class="comment">// v is an Integer value containing 0xDEADBEEF.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// raw string literal (`R&quot;(...)&quot;` is useful for this purpose)</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> t = u8R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">    title = &quot;this is TOML literal&quot;</span></div>
<div class="line"><span class="stringliteral">    [table]</span></div>
<div class="line"><span class="stringliteral">    key = &quot;value&quot;</span></div>
<div class="line"><span class="stringliteral">)&quot;_toml;</span></div>
<div class="line"><span class="stringliteral"></span><span class="comment">// the literal will be parsed and the result will be contained in t</span></div>
<div class="ttc" id="anamespacetoml_1_1literals_1_1toml__literals_html"><div class="ttname"><a href="namespacetoml_1_1literals_1_1toml__literals.html">toml::literals::toml_literals</a></div><div class="ttdef"><b>Definition:</b> literal.hpp:12</div></div>
</div><!-- fragment --><p >The literal function is defined in the same way as the standard library literals such as <code>std::literals::string_literals::operator""s</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">namespace </span>literals</div>
<div class="line">{</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">namespace </span>toml_literals</div>
<div class="line">{</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> <span class="keyword">operator</span><span class="stringliteral">&quot;&quot;</span> _toml(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, std::size_t len);</div>
<div class="line">} <span class="comment">// toml_literals</span></div>
<div class="line">} <span class="comment">// literals</span></div>
<div class="line">} <span class="comment">// toml</span></div>
</div><!-- fragment --><p >Access to the operator can be gained with <code>using namespace <a class="el" href="namespacetoml_1_1literals.html">toml::literals</a>;</code>, <code>using namespace <a class="el" href="namespacetoml_1_1literals_1_1toml__literals.html">toml::toml_literals</a></code>, and <code>using namespace <a class="el" href="namespacetoml_1_1literals_1_1toml__literals.html">toml::literals::toml_literals</a></code>.</p>
<p >Note that a key that is composed only of digits is allowed in TOML. And, unlike the file parser, toml-literal allows a bare value without a key. Thus it is difficult to distinguish arrays having integers and definitions of tables that are named as digits. Currently, literal <code>[1]</code> becomes a table named "1". To ensure a literal to be considered as an array with one element, you need to add a comma after the first element (like <code>[1,]</code>).</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;[1,2,3]&quot;</span>_toml;   <span class="comment">// This is an array</span></div>
<div class="line"><span class="stringliteral">&quot;[table]&quot;</span>_toml;   <span class="comment">// This is a table that has an empty table named &quot;table&quot; inside.</span></div>
<div class="line"><span class="stringliteral">&quot;[[1,2,3]]&quot;</span>_toml; <span class="comment">// This is an array of arrays</span></div>
<div class="line"><span class="stringliteral">&quot;[[table]]&quot;</span>_toml; <span class="comment">// This is a table that has an array of tables inside.</span></div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;[[1]]&quot;</span>_toml;     <span class="comment">// This literal is ambiguous.</span></div>
<div class="line">                  <span class="comment">// Currently, it becomes a table that has array of table &quot;1&quot;.</span></div>
<div class="line"><span class="stringliteral">&quot;1 = [{}]&quot;</span>_toml;  <span class="comment">// This is a table that has an array of table named 1.</span></div>
<div class="line"><span class="stringliteral">&quot;[[1,]]&quot;</span>_toml;    <span class="comment">// This is an array of arrays.</span></div>
<div class="line"><span class="stringliteral">&quot;[[1],]&quot;</span>_toml;    <span class="comment">// ditto.</span></div>
</div><!-- fragment --><p >NOTE: <code>_toml</code> literal returns a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> that does not have comments.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Conversion between toml value and arbitrary types</h1>
<p >You can also use <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> and other related functions with the types you defined after you implement a way to convert it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> data = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// to do this</span></div>
<div class="line"><span class="keyword">const</span> foo f = toml::find&lt;ext::foo&gt;(data, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p >There are 3 ways to use <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> with the types that you defined.</p>
<p >The first one is to implement <code>from_toml(const toml::value&amp;)</code> member function.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> from_toml(<span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>&amp; v)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;a = toml::find&lt;int        &gt;(v, <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">        this-&gt;b = toml::find&lt;double     &gt;(v, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">        this-&gt;c = toml::find&lt;std::string&gt;(v, <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
</div><!-- fragment --><p >In this way, because <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a></code> first constructs <code>foo</code> without arguments, the type should be default-constructible.</p>
<p >The second is to implement <code>constructor(const toml::value&amp;)</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> foo(<span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>&amp; v)</div>
<div class="line">        : a(<a class="code hl_namespace" href="namespacetoml.html">toml</a>::<a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">find</a>&lt;int&gt;(v, <span class="stringliteral">&quot;a&quot;</span>)), b(<a class="code hl_namespace" href="namespacetoml.html">toml</a>::<a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">find</a>&lt;double&gt;(v, <span class="stringliteral">&quot;b&quot;</span>)),</div>
<div class="line">          c(<a class="code hl_namespace" href="namespacetoml.html">toml</a>::<a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">find</a>&lt;std::<a class="code hl_struct" href="structtoml_1_1string.html">string</a>&gt;(v, <span class="stringliteral">&quot;c&quot;</span>))</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
<div class="ttc" id="astructtoml_1_1string_html"><div class="ttname"><a href="structtoml_1_1string.html">toml::string</a></div><div class="ttdef"><b>Definition:</b> string.hpp:30</div></div>
</div><!-- fragment --><p >Note that implicit default constructor declaration will be suppressed when a constructor is defined. If you want to use the struct (here, <code>foo</code>) in a container (e.g. <code>std::vector&lt;foo&gt;</code>), you may need to define default constructor explicitly.</p>
<p >The third is to implement specialization of <code><a class="el" href="structtoml_1_1from.html">toml::from</a></code> for your type.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1from.html">from</a>&lt;ext::foo&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> ext::foo from_toml(<span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">value</a>&amp; v)</div>
<div class="line">    {</div>
<div class="line">        ext::foo f;</div>
<div class="line">        f.a = find&lt;int        &gt;(v, <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">        f.b = find&lt;double     &gt;(v, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">        f.c = find&lt;std::string&gt;(v, <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> f;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="ttc" id="astructtoml_1_1from_html"><div class="ttname"><a href="structtoml_1_1from.html">toml::from</a></div><div class="ttdef"><b>Definition:</b> from.hpp:10</div></div>
</div><!-- fragment --><p >In this way, since the conversion function is defined outside of the class, you can add conversion between <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> and classes defined in another library.</p>
<p >In some cases, a class has a templatized constructor that takes a template, <code>T</code>. It confuses <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>/find&lt;T&gt;</code> because it makes the class "constructible" from <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>. To avoid this problem, <code><a class="el" href="structtoml_1_1from.html">toml::from</a></code> and <code>from_toml</code> always precede constructor. It makes easier to implement conversion between <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> and types defined in other libraries because it skips constructor.</p>
<p >But, importantly, you cannot define <code><a class="el" href="structtoml_1_1from.html">toml::from</a>&lt;T&gt;</code> and <code>T.from_toml</code> at the same time because it causes ambiguity in the overload resolution of <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>&lt;T&gt;</code> and <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>&lt;T&gt;</code>.</p>
<p >So the precedence is <code><a class="el" href="structtoml_1_1from.html">toml::from</a>&lt;T&gt;</code> == <code>T.from_toml()</code> &gt; <code>T(toml::value)</code>.</p>
<p >If you want to convert any versions of <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a></code>, you need to templatize the conversion function as follows.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>M, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>A&gt;</div>
<div class="line">    <span class="keywordtype">void</span> from_toml(<span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;C, M, A&gt;</a>&amp; v)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;a = toml::find&lt;int        &gt;(v, <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">        this-&gt;b = toml::find&lt;double     &gt;(v, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">        this-&gt;c = toml::find&lt;std::string&gt;(v, <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1from.html">from</a>&lt;ext::foo&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>M, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>A&gt;</div>
<div class="line">    <span class="keyword">static</span> ext::foo from_toml(<span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">basic_value&lt;C, M, A&gt;</a>&amp; v)</div>
<div class="line">    {</div>
<div class="line">        ext::foo f;</div>
<div class="line">        f.a = find&lt;int        &gt;(v, <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">        f.b = find&lt;double     &gt;(v, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">        f.c = find&lt;std::string&gt;(v, <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> f;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
</div><!-- fragment --><hr  />
<p >The opposite direction is also supported in a similar way. You can directly pass your type to <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>'s constructor by introducing <code>into_toml</code> or <code><a class="el" href="structtoml_1_1into.html">toml::into</a>&lt;T&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> into_toml() const <span class="comment">// you need to mark it const.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{{<span class="stringliteral">&quot;a&quot;</span>, this-&gt;a}, {<span class="stringliteral">&quot;b&quot;</span>, this-&gt;b}, {<span class="stringliteral">&quot;c&quot;</span>, this-&gt;c}};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
<div class="line"> </div>
<div class="line">ext::foo    f{42, 3.14, <span class="stringliteral">&quot;foobar&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(f);</div>
</div><!-- fragment --><p >The definition of <code><a class="el" href="structtoml_1_1into.html">toml::into</a>&lt;T&gt;</code> is similar to <code><a class="el" href="structtoml_1_1from.html">toml::from</a>&lt;T&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ext</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         a;</div>
<div class="line">    <span class="keywordtype">double</span>      b;</div>
<div class="line">    std::string c;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// ext</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1into.html">into</a>&lt;ext::foo&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> into_toml(<span class="keyword">const</span> ext::foo&amp; f)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{{<span class="stringliteral">&quot;a&quot;</span>, f.a}, {<span class="stringliteral">&quot;b&quot;</span>, f.b}, {<span class="stringliteral">&quot;c&quot;</span>, f.c}};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="line"> </div>
<div class="line">ext::foo    f{42, 3.14, <span class="stringliteral">&quot;foobar&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(f);</div>
<div class="ttc" id="astructtoml_1_1into_html"><div class="ttname"><a href="structtoml_1_1into.html">toml::into</a></div><div class="ttdef"><b>Definition:</b> into.hpp:10</div></div>
</div><!-- fragment --><p >Any type that can be converted to <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, e.g. <code>int</code>, <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> and <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code> are okay to return from <code>into_toml</code>.</p>
<p >You can also return a custom <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a></code> from <code><a class="el" href="structtoml_1_1into.html">toml::into</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1into.html">into</a>&lt;ext::foo&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;toml::preserve_comments&gt;</a> into_toml(<span class="keyword">const</span> ext::foo&amp; f)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::basic_value&lt;toml::preserve_comments&gt;</a> v{{<span class="stringliteral">&quot;a&quot;</span>, f.a}, {<span class="stringliteral">&quot;b&quot;</span>, f.b}, {<span class="stringliteral">&quot;c&quot;</span>, f.c}};</div>
<div class="line">        v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a8f30566aaf9f5bdbaeaea4f177b16ff3">comments</a>().push_back(<span class="stringliteral">&quot; comment&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> v;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
</div><!-- fragment --><p >But note that, if this <code>basic_value</code> would be assigned into other <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> that discards <code>comments</code>, the comments would be dropped.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Macro to automatically define conversion functions</h2>
<p >There is a helper macro that automatically generates conversion functions <code>from</code> and <code>into</code> for a simple struct.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::string s;</div>
<div class="line">    <span class="keywordtype">double</span>      d;</div>
<div class="line">    <span class="keywordtype">int</span>         i;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// foo</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="macros_8hpp.html#a9be62c04e7b5e1e48822549ee0ded64d">TOML11_DEFINE_CONVERSION_NON_INTRUSIVE</a>(foo::Foo, s, d, i)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="check_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> file = <a class="code hl_function" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a>(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> f = toml::find&lt;foo::Foo&gt;(file, <span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="amacros_8hpp_html_a9be62c04e7b5e1e48822549ee0ded64d"><div class="ttname"><a href="macros_8hpp.html#a9be62c04e7b5e1e48822549ee0ded64d">TOML11_DEFINE_CONVERSION_NON_INTRUSIVE</a></div><div class="ttdeci">#define TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(NAME,...)</div><div class="ttdef"><b>Definition:</b> macros.hpp:93</div></div>
</div><!-- fragment --><p >And then you can use <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>&lt;foo::Foo&gt;(file, "foo");</code></p>
<p ><b>Note</b> that, because of a slight difference in implementation of preprocessor between gcc/clang and MSVC, <a href="https://github.com/ToruNiina/toml11/issues/139#issuecomment-803683682">you need to define <code>/Zc:preprocessor</code></a> to use it in MSVC (Thank you @glebm !).</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Formatting user-defined error messages</h1>
<p >When you encounter an error after you read the toml value, you may want to show the error with the value.</p>
<p >toml11 provides you a function that formats user-defined error message with related values. With a code like the following,</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">value</a> = toml::find&lt;int&gt;(data, <span class="stringliteral">&quot;num&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_class" href="classtoml_1_1basic__value.html">value</a> &lt; 0)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] value should be positive&quot;</span>,</div>
<div class="line">                                    data.at(<span class="stringliteral">&quot;num&quot;</span>), <span class="stringliteral">&quot;positive number required&quot;</span>)</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacetoml_html_af7b41f59a3dcc37f785776b1b9601bfd"><div class="ttname"><a href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a></div><div class="ttdeci">std::string format_error(const std::string &amp;err_msg, const basic_value&lt; C, T, A &gt; &amp;v, const std::string &amp;comment, std::vector&lt; std::string &gt; hints={}, const bool colorize=TOML11_ERROR_MESSAGE_COLORIZED)</div><div class="ttdef"><b>Definition:</b> value.hpp:1928</div></div>
</div><!-- fragment --><p >you will get an error message like this.</p>
<div class="fragment"><div class="line">[error] value should be positive</div>
<div class="line"> --&gt; example.toml</div>
<div class="line"> 3 | num = -42</div>
<div class="line">   |       ~~~ positive number required</div>
</div><!-- fragment --><p >When you pass two values to <code><a class="el" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a></code>,</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> min = toml::find&lt;int&gt;(range, <span class="stringliteral">&quot;min&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> max = toml::find&lt;int&gt;(range, <span class="stringliteral">&quot;max&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(max &lt; min)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] max should be larger than min&quot;</span>,</div>
<div class="line">                                    data.at(<span class="stringliteral">&quot;min&quot;</span>), <span class="stringliteral">&quot;minimum number here&quot;</span>,</div>
<div class="line">                                    data.at(<span class="stringliteral">&quot;max&quot;</span>), <span class="stringliteral">&quot;maximum number here&quot;</span>);</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p >you will get an error message like this.</p>
<div class="fragment"><div class="line">[error] max should be larger than min</div>
<div class="line"> --&gt; example.toml</div>
<div class="line"> 3 | min = 54</div>
<div class="line">   |       ~~ minimum number here</div>
<div class="line"> ...</div>
<div class="line"> 4 | max = 42</div>
<div class="line">   |       ~~ maximum number here</div>
</div><!-- fragment --><p >You can print hints at the end of the message.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; hints;</div>
<div class="line">hints.push_back(<span class="stringliteral">&quot;positive number means n &gt;= 0.&quot;</span>);</div>
<div class="line">hints.push_back(<span class="stringliteral">&quot;negative number is not positive.&quot;</span>);</div>
<div class="line">std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] value should be positive&quot;</span>,</div>
<div class="line">                                data.at(<span class="stringliteral">&quot;num&quot;</span>), <span class="stringliteral">&quot;positive number required&quot;</span>, hints)</div>
<div class="line">          &lt;&lt; std::endl;</div>
</div><!-- fragment --><div class="fragment"><div class="line">[error] value should be positive</div>
<div class="line"> --&gt; example.toml</div>
<div class="line"> 2 | num = 42</div>
<div class="line">   |       ~~ positive number required</div>
<div class="line">   |</div>
<div class="line">Hint: positive number means n &gt;= 0.</div>
<div class="line">Hint: negative number is not positive.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Obtaining location information</h1>
<p >You can also format error messages in your own way by using <code>source_location</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1source__location.html">source_location</a></div>
<div class="line">{</div>
<div class="line">    std::uint_least32_t line()      const noexcept;</div>
<div class="line">    std::uint_least32_t column()    const noexcept;</div>
<div class="line">    std::uint_least32_t region()    const noexcept;</div>
<div class="line">    std::<span class="keywordtype">string</span> const&amp;  file_name() const noexcept;</div>
<div class="line">    std::<span class="keywordtype">string</span> const&amp;  line_str()  const noexcept;</div>
<div class="line">};</div>
<div class="line"><span class="comment">// +-- line()       +--- length of the region (here, region() == 9)</span></div>
<div class="line"><span class="comment">// v            .---+---.</span></div>
<div class="line"><span class="comment">// 12 | value = &quot;foo bar&quot; &lt;- line_str() returns the line itself.</span></div>
<div class="line"><span class="comment">//              ^-------- column() points here</span></div>
<div class="ttc" id="astructtoml_1_1source__location_html"><div class="ttname"><a href="structtoml_1_1source__location.html">toml::source_location</a></div><div class="ttdef"><b>Definition:</b> source_location.hpp:39</div></div>
</div><!-- fragment --><p >You can get this by </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>           v   = <span class="comment">/*...*/</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structtoml_1_1source__location.html">toml::source_location</a> loc = v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a0d39990ac7a3394568165926aed4634a">location</a>();</div>
<div class="ttc" id="aclasstoml_1_1basic__value_html_a0d39990ac7a3394568165926aed4634a"><div class="ttname"><a href="classtoml_1_1basic__value.html#a0d39990ac7a3394568165926aed4634a">toml::basic_value::location</a></div><div class="ttdeci">source_location location() const</div><div class="ttdef"><b>Definition:</b> value.hpp:1701</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md34"></a>
Exceptions</h1>
<p >The following <code>exception</code> classes inherits <code><a class="el" href="structtoml_1_1exception.html">toml::exception</a></code> that inherits <code>std::exception</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a> {</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1exception.html">exception</a>      : <span class="keyword">public</span> std::exception  {};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1syntax__error.html">syntax_error</a>   : <span class="keyword">public</span> <a class="code hl_struct" href="structtoml_1_1exception.html">toml::exception</a> {};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1type__error.html">type_error</a>     : <span class="keyword">public</span> <a class="code hl_struct" href="structtoml_1_1exception.html">toml::exception</a> {};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1internal__error.html">internal_error</a> : <span class="keyword">public</span> <a class="code hl_struct" href="structtoml_1_1exception.html">toml::exception</a> {};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="ttc" id="astructtoml_1_1exception_html"><div class="ttname"><a href="structtoml_1_1exception.html">toml::exception</a></div><div class="ttdef"><b>Definition:</b> exception.hpp:14</div></div>
<div class="ttc" id="astructtoml_1_1internal__error_html"><div class="ttname"><a href="structtoml_1_1internal__error.html">toml::internal_error</a></div><div class="ttdef"><b>Definition:</b> exception.hpp:52</div></div>
<div class="ttc" id="astructtoml_1_1syntax__error_html"><div class="ttname"><a href="structtoml_1_1syntax__error.html">toml::syntax_error</a></div><div class="ttdef"><b>Definition:</b> exception.hpp:26</div></div>
<div class="ttc" id="astructtoml_1_1type__error_html"><div class="ttname"><a href="structtoml_1_1type__error.html">toml::type_error</a></div><div class="ttdef"><b>Definition:</b> exception.hpp:39</div></div>
</div><!-- fragment --><p ><code><a class="el" href="structtoml_1_1exception.html">toml::exception</a></code> has <code><a class="el" href="structtoml_1_1exception.html#a11530f5a06324266a9462e6042efc72a">toml::exception::location()</a></code> member function that returns <code><a class="el" href="structtoml_1_1source__location.html">toml::source_location</a></code>, in addition to <code>what()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacetoml.html">toml</a> {</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structtoml_1_1exception.html">exception</a> : <span class="keyword">public</span> std::exception</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <a class="code hl_struct" href="structtoml_1_1source__location.html">source_location</a> <span class="keyword">const</span>&amp; <a class="code hl_function" href="structtoml_1_1exception.html#a11530f5a06324266a9462e6042efc72a">location</a>() const noexcept;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// toml</span></div>
<div class="ttc" id="astructtoml_1_1exception_html_a11530f5a06324266a9462e6042efc72a"><div class="ttname"><a href="structtoml_1_1exception.html#a11530f5a06324266a9462e6042efc72a">toml::exception::location</a></div><div class="ttdeci">virtual source_location const &amp; location() const noexcept</div><div class="ttdef"><b>Definition:</b> exception.hpp:19</div></div>
</div><!-- fragment --><p >It represents where the error occurs.</p>
<p ><code>syntax_error</code> will be thrown from <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> and <code>_toml</code> literal. <code>type_error</code> will be thrown from <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>/find</code>, <code>toml::value::as_xxx()</code>, and other functions that takes a content inside of <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>.</p>
<p >Note that, currently, from <code><a class="el" href="classtoml_1_1basic__value.html#ad497266e16a1aa285d224dcf51fa622a">toml::value::at()</a></code> and <code>toml::find(value, key)</code> may throw an <code>std::out_of_range</code> that does not inherits <code><a class="el" href="structtoml_1_1exception.html">toml::exception</a></code>.</p>
<p >Also, in some cases, most likely in the file open error, it will throw an <code>std::runtime_error</code>.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Colorize Error Messages</h1>
<p >By defining <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, the error messages from <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> and <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a>|get</code> will be colorized. By default, this feature is turned off.</p>
<p >With the following toml file taken from <code>toml-lang/toml/tests/hard_example.toml</code>,</p>
<div class="fragment"><div class="line">[error]</div>
<div class="line">array = [</div>
<div class="line">         &quot;This might most likely happen in multiline arrays&quot;,</div>
<div class="line">         Like here,</div>
<div class="line">         &quot;or here,</div>
<div class="line">         and here&quot;</div>
<div class="line">        ]     End of array comment, forgot the #</div>
</div><!-- fragment --><p >the error message would be like this.</p>
<p ><img src="https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-1.png" alt="error-message-1" class="inline"/></p>
<p >With the following,</p>
<div class="fragment"><div class="line">[error]</div>
<div class="line"># array = [</div>
<div class="line">#          &quot;This might most likely happen in multiline arrays&quot;,</div>
<div class="line">#          Like here,</div>
<div class="line">#          &quot;or here,</div>
<div class="line">#          and here&quot;</div>
<div class="line">#         ]     End of array comment, forgot the #</div>
<div class="line">number = 3.14  pi &lt;--again forgot the #</div>
</div><!-- fragment --><p >the error message would be like this.</p>
<p ><img src="https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-2.png" alt="error-message-2" class="inline"/></p>
<p >The message would be messy when it is written to a file, not a terminal because it uses <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code</a>.</p>
<p >Without <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, you can still colorize user-defined error message by passing <code>true</code> to the <code><a class="el" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a></code> function. If you define <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, the value is <code>true</code> by default. If not, the default value would be <code>false</code>.</p>
<div class="fragment"><div class="line">std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] value should be positive&quot;</span>,</div>
<div class="line">                                data.at(<span class="stringliteral">&quot;num&quot;</span>), <span class="stringliteral">&quot;positive number required&quot;</span>,</div>
<div class="line">                                hints, <span class="comment">/*colorize = */</span> <span class="keyword">true</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >Note: It colorizes <code>[error]</code> in red. That means that it detects <code>[error]</code> prefix at the front of the error message. If there is no <code>[error]</code> prefix, <code>format_error</code> adds it to the error message.</p>
<p >Compared to the <code>TOML11_COLORIZE_ERROR_MESSAGE</code> macro that enables colorization statically, toml11 provides <code>toml::color::enable</code> &amp; <code>toml::color::disable</code> functions to dynamically change the color mode. This feature overwrites <code>TOML11_COLORIZE_ERROR_MESSAGE</code> and the <code>colorize</code> argument of <code><a class="el" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a></code> when you call <code>enable</code>.</p>
<p >Note: If either <code>TOML11_COLORIZE_ERROR_MESSAGE</code> is defined or the <code>colorize</code> argument is used, it takes precedence, meaning that <code>disable</code> won't work. Accordingly, we highly recommend using only one of them.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacetoml_1_1color__ansi.html#abc159bcd963aff04afbed630fc976480">toml::color::enable</a>();  <span class="comment">// enable colorization</span></div>
<div class="line"><a class="code hl_function" href="namespacetoml_1_1color__ansi.html#a016c42beb0b7a87a1a952161652b8fb2">toml::color::disable</a>(); <span class="comment">// disable colorization</span></div>
<div class="ttc" id="anamespacetoml_1_1color__ansi_html_a016c42beb0b7a87a1a952161652b8fb2"><div class="ttname"><a href="namespacetoml_1_1color__ansi.html#a016c42beb0b7a87a1a952161652b8fb2">toml::color_ansi::disable</a></div><div class="ttdeci">void disable()</div><div class="ttdef"><b>Definition:</b> color.hpp:93</div></div>
<div class="ttc" id="anamespacetoml_1_1color__ansi_html_abc159bcd963aff04afbed630fc976480"><div class="ttname"><a href="namespacetoml_1_1color__ansi.html#abc159bcd963aff04afbed630fc976480">toml::color_ansi::enable</a></div><div class="ttdeci">void enable()</div><div class="ttdef"><b>Definition:</b> color.hpp:89</div></div>
</div><!-- fragment --><p >If you use user-defined error message, you can manage the setting as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacetoml_1_1color__ansi.html#abc159bcd963aff04afbed630fc976480">toml::color::enable</a>();</div>
<div class="line">std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] value should be positive&quot;</span>,</div>
<div class="line">                                data.at(<span class="stringliteral">&quot;num&quot;</span>), <span class="stringliteral">&quot;positive number required&quot;</span>,</div>
<div class="line">                                hints) &lt;&lt; std::endl; <span class="comment">// colorized</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacetoml_1_1color__ansi.html#a016c42beb0b7a87a1a952161652b8fb2">toml::color::disable</a>();</div>
<div class="line">std::cerr &lt;&lt; <a class="code hl_function" href="namespacetoml.html#af7b41f59a3dcc37f785776b1b9601bfd">toml::format_error</a>(<span class="stringliteral">&quot;[error] value should be positive&quot;</span>,</div>
<div class="line">                                data.at(<span class="stringliteral">&quot;num&quot;</span>), <span class="stringliteral">&quot;positive number required&quot;</span>,</div>
<div class="line">                                hints) &lt;&lt; std::endl; <span class="comment">// NOT colorized</span></div>
</div><!-- fragment --><p >Or you may use toml11 in your application like:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; args(argv + 1, argv + argc);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structtoml_1_1result.html">result</a> = <a class="code hl_variable" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">std::find</a>(args.begin(), args.end(), <span class="stringliteral">&quot;--color&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_struct" href="structtoml_1_1result.html">result</a> != args.end()) {</div>
<div class="line">    <a class="code hl_function" href="namespacetoml_1_1color__ansi.html#abc159bcd963aff04afbed630fc976480">toml::color::enable</a>();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacetoml_1_1color__ansi.html#a016c42beb0b7a87a1a952161652b8fb2">toml::color::disable</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// use toml11 ...</span></div>
<div class="ttc" id="astructtoml_1_1result_html"><div class="ttname"><a href="structtoml_1_1result.html">toml::result</a></div><div class="ttdef"><b>Definition:</b> result.hpp:106</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md36"></a>
Opting out of the default &lt;tt&gt;[error]&lt;/tt&gt; prefix</h1>
<p >toml11 prints error messages with the <code>[error]</code> prefix by default. Defining <code>TOML11_NO_ERROR_PREFIX</code> will let toml11 omit the prefix regardless of colorized or not in case you would use a custom prefix, such as <code>Error:</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define TOML11_NO_ERROR_PREFIX</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
Serializing TOML data</h1>
<p >toml11 enables you to serialize data into toml format.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> data{{<span class="stringliteral">&quot;foo&quot;</span>, 42}, {<span class="stringliteral">&quot;bar&quot;</span>, <span class="stringliteral">&quot;baz&quot;</span>}};</div>
<div class="line">std::cout &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// bar = &quot;baz&quot;</span></div>
<div class="line"><span class="comment">// foo = 42</span></div>
</div><!-- fragment --><p >toml11 automatically makes a small table and small array inline. You can specify the width to make them inline by <code>std::setw</code> for streams.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> data{</div>
<div class="line">    {<span class="stringliteral">&quot;qux&quot;</span>,    {{<span class="stringliteral">&quot;foo&quot;</span>, 42}, {<span class="stringliteral">&quot;bar&quot;</span>, <span class="stringliteral">&quot;baz&quot;</span>}}},</div>
<div class="line">    {<span class="stringliteral">&quot;quux&quot;</span>,   {<span class="stringliteral">&quot;small&quot;</span>, <span class="stringliteral">&quot;array&quot;</span>, <span class="stringliteral">&quot;of&quot;</span>, <span class="stringliteral">&quot;strings&quot;</span>}},</div>
<div class="line">    {<span class="stringliteral">&quot;foobar&quot;</span>, {<span class="stringliteral">&quot;this&quot;</span>, <span class="stringliteral">&quot;array&quot;</span>, <span class="stringliteral">&quot;of&quot;</span>, <span class="stringliteral">&quot;strings&quot;</span>, <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;too&quot;</span>, <span class="stringliteral">&quot;long&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;to&quot;</span>, <span class="stringliteral">&quot;print&quot;</span>, <span class="stringliteral">&quot;into&quot;</span>, <span class="stringliteral">&quot;single&quot;</span>, <span class="stringliteral">&quot;line&quot;</span>, <span class="stringliteral">&quot;isn&#39;t&quot;</span>, <span class="stringliteral">&quot;it?&quot;</span>}},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the threshold becomes 80.</span></div>
<div class="line">std::cout &lt;&lt; std::setw(80) &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// foobar = [</span></div>
<div class="line"><span class="comment">// &quot;this&quot;,&quot;array&quot;,&quot;of&quot;,&quot;strings&quot;,&quot;is&quot;,&quot;too&quot;,&quot;long&quot;,&quot;to&quot;,&quot;print&quot;,&quot;into&quot;,</span></div>
<div class="line"><span class="comment">// &quot;single&quot;,&quot;line&quot;,&quot;isn&#39;t&quot;,&quot;it?&quot;,</span></div>
<div class="line"><span class="comment">// ]</span></div>
<div class="line"><span class="comment">// quux = [&quot;small&quot;,&quot;array&quot;,&quot;of&quot;,&quot;strings&quot;]</span></div>
<div class="line"><span class="comment">// qux = {bar=&quot;baz&quot;,foo=42}</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// the width is 0. nothing become inline.</span></div>
<div class="line">std::cout &lt;&lt; std::setw(0) &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// foobar = [</span></div>
<div class="line"><span class="comment">// &quot;this&quot;,</span></div>
<div class="line"><span class="comment">// ... (snip)</span></div>
<div class="line"><span class="comment">// &quot;it?&quot;,</span></div>
<div class="line"><span class="comment">// ]</span></div>
<div class="line"><span class="comment">// quux = [</span></div>
<div class="line"><span class="comment">// &quot;small&quot;,</span></div>
<div class="line"><span class="comment">// &quot;array&quot;,</span></div>
<div class="line"><span class="comment">// &quot;of&quot;,</span></div>
<div class="line"><span class="comment">// &quot;strings&quot;,</span></div>
<div class="line"><span class="comment">// ]</span></div>
<div class="line"><span class="comment">// [qux]</span></div>
<div class="line"><span class="comment">// bar = &quot;baz&quot;</span></div>
<div class="line"><span class="comment">// foo = 42</span></div>
</div><!-- fragment --><p >It is recommended to set width before printing data. Some I/O functions changes width to 0, and it makes all the stuff (including <code><a class="el" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a></code>) multiline. The resulting files becomes too long.</p>
<p >To control the precision of floating point numbers, you need to pass <code>std::setprecision</code> to stream.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> data{</div>
<div class="line">    {<span class="stringliteral">&quot;pi&quot;</span>, 3.141592653589793},</div>
<div class="line">    {<span class="stringliteral">&quot;e&quot;</span>,  2.718281828459045}</div>
<div class="line">};</div>
<div class="line">std::cout &lt;&lt; std::setprecision(17) &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// e = 2.7182818284590451</span></div>
<div class="line"><span class="comment">// pi = 3.1415926535897931</span></div>
<div class="line">std::cout &lt;&lt; std::setprecision( 7) &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// e = 2.718282</span></div>
<div class="line"><span class="comment">// pi = 3.141593</span></div>
</div><!-- fragment --><p >There is another way to format toml values, <code><a class="el" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format()</a></code>. It returns <code>std::string</code> that represents a value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{{<span class="stringliteral">&quot;a&quot;</span>, 42}};</div>
<div class="line"><span class="keyword">const</span> std::string fmt = <a class="code hl_function" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a>(v);</div>
<div class="line"><span class="comment">// a = 42</span></div>
<div class="ttc" id="anamespacetoml_html_a63b9229f5457581fe01b48f68b06bfe7"><div class="ttname"><a href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a></div><div class="ttdeci">std::string format(const basic_value&lt; C, M, V &gt; &amp;v, std::size_t w=80u, int fprec=std::numeric_limits&lt; toml::floating &gt;::max_digits10, bool no_comment=false, bool force_inline=false)</div><div class="ttdef"><b>Definition:</b> serializer.hpp:821</div></div>
</div><!-- fragment --><p >Note that since <code><a class="el" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a></code> formats a value, the resulting string may lack the key value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{3.14};</div>
<div class="line"><span class="keyword">const</span> std::string fmt = <a class="code hl_function" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a>(v);</div>
<div class="line"><span class="comment">// 3.14</span></div>
</div><!-- fragment --><p >To control the width and precision, <code><a class="el" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a></code> receives optional second and third arguments to set them. By default, the width is 80 and the precision is <code>std::numeric_limits&lt;double&gt;::max_digit10</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> serial = <a class="code hl_function" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a>(data, <span class="comment">/*width = */</span> 0, <span class="comment">/*prec = */</span> 17);</div>
</div><!-- fragment --><p >When you pass a comment-preserving-value, the comment will also be serialized. An array or a table containing a value that has a comment would not be inlined.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Underlying types</h1>
<p >The toml types (can be used as <code>toml::*</code> in this library) and corresponding <code>enum</code> names are listed in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">TOML type   </th><th class="markdownTableHeadNone">underlying c++ type   </th><th class="markdownTableHeadNone">enum class    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27">toml::value_t::boolean</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone"><code>std::int64_t</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8">toml::value_t::integer</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Float   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17">toml::value_t::floating</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code><a class="el" href="structtoml_1_1string.html">toml::string</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21">toml::value_t::string</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LocalDate   </td><td class="markdownTableBodyNone"><code><a class="el" href="structtoml_1_1local__date.html">toml::local_date</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaaa9647613bc34fa481cf7bfd71e46511f">toml::value_t::local_date</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LocalTime   </td><td class="markdownTableBodyNone"><code><a class="el" href="structtoml_1_1local__time.html">toml::local_time</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaad118bc9b5fdddd0a0c91b99a41bb9501">toml::value_t::local_time</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LocalDatetime   </td><td class="markdownTableBodyNone"><code><a class="el" href="structtoml_1_1local__datetime.html">toml::local_datetime</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa4786c634d28e7c1aa109efdd9e11ba32">toml::value_t::local_datetime</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OffsetDatetime   </td><td class="markdownTableBodyNone"><code><a class="el" href="structtoml_1_1offset__datetime.html">toml::offset_datetime</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaa3453afefc0169f713370ff6bea1dc9a5">toml::value_t::offset_datetime</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>array-like&lt;<a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>&gt;</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaaf1f713c9e000f5d3f280adbd124df4f5">toml::value_t::array</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Table   </td><td class="markdownTableBodyNone"><code>map-like&lt;<a class="el" href="namespacetoml.html#ab00c292fbb2e761ef69fdafd6b813348">toml::key</a>, <a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>&gt;</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaaaaab9e1de16f38176f86d7a92ba337a8d">toml::value_t::table</a></code>   </td></tr>
</table>
<p ><code>array-like</code> and <code>map-like</code> are the STL containers that works like a <code>std::vector</code> and <code>std::unordered_map</code>, respectively. By default, <code>std::vector</code> and <code>std::unordered_map</code> are used. See Customizing containers for detail.</p>
<p ><code><a class="el" href="structtoml_1_1string.html">toml::string</a></code> is effectively the same as <code>std::string</code> but has an additional flag that represents a kind of a string, <code>string_t::basic</code> and <code>string_t::literal</code>. Although <code>std::string</code> is not an exact toml type, still you can get a reference that points to internal <code>std::string</code> by using <code><a class="el" href="namespacetoml.html#a2e4b27fae0d9dc6b824e77b12112f313">toml::get</a>&lt;std::string&gt;()</code> for convenience. The most important difference between <code>std::string</code> and <code><a class="el" href="structtoml_1_1string.html">toml::string</a></code> is that <code><a class="el" href="structtoml_1_1string.html">toml::string</a></code> will be formatted as a TOML string when outputted with <code>ostream</code>. This feature is introduced to make it easy to write a custom serializer.</p>
<p ><code>Datetime</code> variants are <code>struct</code> that are defined in this library. Because <code>std::chrono::system_clock::time_point</code> is a <b>time point</b>, not capable of representing a Local Time independent from a specific day.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Unreleased TOML features</h1>
<p >After TOML v1.0.0 has been released, some features are added to the main branch of the TOML spec repository. (see: <a href="https://github.com/toml-lang/toml/blob/main/CHANGELOG.md">CHANGELOG.md in toml-lang/toml repository</a>).</p>
<p >The following list shows available "unreleased" features that can be activated by defining a macro named <code>TOML11_USE_UNRELEASED_FEATURES</code>.</p>
<ul>
<li>Add new <code>\e</code> shorthand for the escape character.</li>
</ul>
<h1><a class="anchor" id="autotoc_md40"></a>
Note about heterogeneous arrays</h1>
<p >Although <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> allows heterogeneous arrays, constructor of <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> does not. Here the reason is explained.</p>
<div class="fragment"><div class="line"><span class="comment">// this won&#39;t be compiled</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{</div>
<div class="line">    <span class="stringliteral">&quot;foo&quot;</span>, 3.14, 42, {1,2,3,4,5}, {{<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>}}</div>
<div class="line">}</div>
</div><!-- fragment --><p >There is a workaround for this. By explicitly converting values into <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, you can initialize <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> with a heterogeneous array. Also, you can first initialize a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> with an array and then <code>push_back</code> into it.</p>
<div class="fragment"><div class="line"><span class="comment">// OK!</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{</div>
<div class="line">    <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(<span class="stringliteral">&quot;foo&quot;</span>), <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(3.14), <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(42),</div>
<div class="line">    <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{1,2,3,4,5}, <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{{<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>}}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// OK!</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(<a class="code hl_typedef" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a>{});</div>
<div class="line">v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a5070496463735ce25ae8765ab5cb90ad">push_back</a>(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="classtoml_1_1basic__value.html#a5070496463735ce25ae8765ab5cb90ad">push_back</a>(3.14);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// OK!</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetoml.html#a4db748c68f34deac79e0b45535cfb3b6">toml::array</a> a;</div>
<div class="line">a.push_back(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">a.push_back(3.14);</div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v(std::move(a));</div>
</div><!-- fragment --><p >The reason why the first example is not allowed is the following. Let's assume that you are initializing a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> with a table.</p>
<div class="fragment"><div class="line">                    <span class="comment">// # expecting TOML table.</span></div>
<div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{      <span class="comment">// [v]</span></div>
<div class="line">    {<span class="stringliteral">&quot;answer&quot;</span>, 42}, <span class="comment">// answer = 42</span></div>
<div class="line">    {<span class="stringliteral">&quot;pi&quot;</span>,   3.14}, <span class="comment">// pi = 3.14</span></div>
<div class="line">    {<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>}  <span class="comment">// foo = &quot;bar&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >This is indistinguishable from a (heterogeneous) TOML array definition.</p>
<div class="fragment"><div class="line">v = [</div>
<div class="line">    [&quot;answer&quot;, 42],</div>
<div class="line">    [&quot;pi&quot;,   3.14],</div>
<div class="line">    [&quot;foo&quot;, &quot;bar&quot;],</div>
<div class="line">]</div>
</div><!-- fragment --><p >This means that the above C++ code makes constructor's overload resolution ambiguous. So a constructor that allows both "table as an initializer-list" and "heterogeneous array as an initializer-list" cannot be implemented.</p>
<p >Thus, although it is painful, we need to explicitly cast values into <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> when you initialize heterogeneous array in a C++ code.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a> v{</div>
<div class="line">    <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(<span class="stringliteral">&quot;foo&quot;</span>), <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(3.14), <a class="code hl_typedef" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a>(42),</div>
<div class="line">    <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{1,2,3,4,5}, <a class="code hl_class" href="classtoml_1_1basic__value.html">toml::value</a>{{<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>}}</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
Breaking Changes from v2</h1>
<p >Although toml11 is relatively new library (it's three years old now), it had some confusing and inconvenient user-interfaces because of historical reasons.</p>
<p >Between v2 and v3, those interfaces are rearranged.</p>
<ul>
<li><code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> now returns a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, not <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code>.</li>
<li><code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> is now an alias of <code><a class="el" href="classtoml_1_1basic__value.html">toml::basic_value</a>&lt;discard_comment, std::vector, std::unordered_map&gt;</code>.<ul>
<li>See Customizing containers for detail.</li>
</ul>
</li>
<li>The elements of <code><a class="el" href="namespacetoml.html#a99b223fe1b911188b415ace2e80d9aaa">toml::value_t</a></code> are renamed as <code>snake_case</code>.<ul>
<li>See Underlying types for detail.</li>
</ul>
</li>
<li>Supports for the CamelCaseNames are dropped.<ul>
<li>See Underlying types for detail.</li>
</ul>
</li>
<li><code>(is|as)_float</code> has been removed to make the function names consistent with others.<ul>
<li>Since <code>float</code> is a keyword, toml11 named a float type as <code><a class="el" href="namespacetoml.html#a54f4b85eab8f0d6e6f0149c5ba338f6a">toml::floating</a></code>.</li>
<li>Also a <code>value_t</code> corresponds to <code><a class="el" href="namespacetoml.html#a54f4b85eab8f0d6e6f0149c5ba338f6a">toml::floating</a></code> is named <code>value_t::floating</code>.</li>
<li>So <code>(is|as)_floating</code> is introduced and <code>is_float</code> has been removed.</li>
<li>See Casting a toml::value and Checking value type for detail.</li>
</ul>
</li>
<li>An overload of <code><a class="el" href="namespacetoml.html#a31abd17e078e497fb224d79260910b8d">toml::find</a></code> for <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> has been dropped. Use <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> version instead.<ul>
<li>Because type conversion between a table and a value causes ambiguity while overload resolution</li>
<li>Since <code><a class="el" href="namespacetoml.html#ad3d7c729037d3e6cb19515babf8539a3">toml::parse</a></code> now returns a <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code>, this feature becomes less important.</li>
<li>Also because <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code> is a normal STL container, implementing utility function is easy.</li>
<li>See Finding a toml::value for detail.</li>
</ul>
</li>
<li>An overload of <code>operator&lt;&lt;</code> and <code><a class="el" href="namespacetoml.html#a63b9229f5457581fe01b48f68b06bfe7">toml::format</a></code> for <code><a class="el" href="namespacetoml.html#af7d788a576baa570efd4793cd5df8ac7">toml::table</a></code>s are dropped.<ul>
<li>Use <code><a class="el" href="namespacetoml.html#a34e466167cc683c477838accdebb2578">toml::value</a></code> instead.</li>
<li>See Serializing TOML data for detail.</li>
</ul>
</li>
<li>Interface around comments.<ul>
<li>See Preserving Comments for detail.</li>
</ul>
</li>
<li>An ancient <code>from_toml/into_toml</code> has been removed. Use arbitrary type conversion support.<ul>
<li>See Conversion between toml value and arbitrary types for detail.</li>
</ul>
</li>
</ul>
<p >Such a big change will not happen in the coming years.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Running Tests</h1>
<p >After cloning this repository, run the following command (thank you @jwillikers for automating test set fetching!).</p>
<div class="fragment"><div class="line">$ mkdir build</div>
<div class="line">$ cd build</div>
<div class="line">$ cmake .. -Dtoml11_BUILD_TEST=ON</div>
<div class="line">$ make</div>
<div class="line">$ make test</div>
</div><!-- fragment --><p >To run the language agnostic test suite, you need to compile <code><a class="el" href="check__toml__test_8cpp.html">tests/check_toml_test.cpp</a></code> and pass it to the tester.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Contributors</h1>
<p >I appreciate the help of the contributors who introduced the great feature to this library.</p>
<ul>
<li>Guillaume Fraux (@Luthaf)<ul>
<li>Windows support and CI on Appvayor</li>
<li>Intel Compiler support</li>
</ul>
</li>
<li>Quentin Khan (@xaxousis)<ul>
<li>Found &amp; Fixed a bug around ODR</li>
<li>Improved error messages for invalid keys to show the location where the parser fails</li>
</ul>
</li>
<li>Petr Beneš (@wbenny)<ul>
<li>Fixed warnings on MSVC</li>
</ul>
</li>
<li>Ivan Shynkarenka (@chronoxor)<ul>
<li>Fixed Visual Studio 2019 warnings</li>
</ul>
</li>
<li>Khoi Dinh Trinh (@khoitd1997)<ul>
<li>Fixed warnings while type conversion</li>
</ul>
</li>
<li>@KerstinKeller<ul>
<li>Added installation script to CMake</li>
</ul>
</li>
<li>J.C. Moyer (@jcmoyer)<ul>
<li>Fixed an example code in the documentation</li>
</ul>
</li>
<li>Jt Freeman (@blockparty-sh)<ul>
<li>Fixed feature test macro around <code>localtime_s</code></li>
<li>Suppress warnings in Debug mode</li>
</ul>
</li>
<li>OGAWA Kenichi (@kenichiice)<ul>
<li>Suppress warnings on intel compiler</li>
</ul>
</li>
<li>Jordan Williams (@jwillikers)<ul>
<li>Fixed clang range-loop-analysis warnings</li>
<li>Fixed feature test macro to suppress -Wundef</li>
<li>Use cache variables in CMakeLists.txt</li>
<li>Automate test set fetching, update and refactor CMakeLists.txt</li>
</ul>
</li>
<li>Scott McCaskill<ul>
<li>Parse 9 digits (nanoseconds) of fractional seconds in a <code>local_time</code></li>
</ul>
</li>
<li>Shu Wang (@halfelf)<ul>
<li>fix "Finding a value in an array" example in README</li>
</ul>
</li>
<li>@maass-tv and @SeverinLeonhardt<ul>
<li>Fix MSVC warning C4866</li>
</ul>
</li>
<li>OGAWA KenIchi (@kenichiice)<ul>
<li>Fix include path in README</li>
</ul>
</li>
<li>Mohammed Alyousef (@MoAlyousef)<ul>
<li>Made testing optional in CMake</li>
</ul>
</li>
<li>Ivan Shynkarenka (@chronoxor)<ul>
<li>Fix compilation error in <code>&lt;filesystem&gt;</code> with MinGW</li>
</ul>
</li>
<li>Alex Merry (@amerry)<ul>
<li>Add missing include files</li>
</ul>
</li>
<li>sneakypete81 (@sneakypete81)<ul>
<li>Fix typo in error message</li>
</ul>
</li>
<li>Oliver Kahrmann (@founderio)<ul>
<li>Fix missing filename in error message if parsed file is empty</li>
</ul>
</li>
<li>Karl Nilsson (@karl-nilsson)<ul>
<li>Fix many spelling errors</li>
</ul>
</li>
<li>ohdarling88 (@ohdarling)<ul>
<li>Fix a bug in a constructor of serializer</li>
</ul>
</li>
<li>estshorter (@estshorter)<ul>
<li>Fix MSVC warning C26478</li>
</ul>
</li>
<li>Philip Top (@phlptp)<ul>
<li>Improve checking standard library feature availability check</li>
</ul>
</li>
<li>Louis Marascio (@marascio)<ul>
<li>Fix free-nonheap-object warning</li>
</ul>
</li>
<li>Axel Huebl (@ax3l)<ul>
<li>Make installation optional if the library is embedded</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md44"></a>
Licensing terms</h1>
<p >This product is licensed under the terms of the [MIT License](LICENSE).</p>
<ul>
<li>Copyright (c) 2017-2022 Toru Niina</li>
</ul>
<p >All rights reserved. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4, using the excellent <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a> Theme</li>
  </ul>
</div>
</body>
</html>
